<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='iOS应用程序加载 前言 这篇文章的核心目的是跟着苹果源码，深度学习并理解iOS APP启动过程。
基础概念 冷启动  冷启动 
 注意：在日常开发或测试的时候为了，触发冷启动状态，会手动kill app，然后点击启动。这种情况下的冷启动可能会与上述冷启动过程的步骤稍微少些，可以配合Instrument调试验证（这个在文章结尾会做介绍）。因此通常如果要模拟更真实全面的冷启动，在kill app后，再打开/并稍微使用几个其他app。
 通常说的启动，也是指的冷启动；启动优化大部分也是做冷启动部分的性能优化 暂且可以把冷启动分为几个阶段：
 T1: main之前，加载App可执行文件到内存，然后执行一系列的加载&amp;amp;链接等工作，最后执行到main()函数 T2: main之后，didFinishLaunching之前，这部分开发是可以监听到的 T3: didFinishLaunching之后，启动页面出现之前，也是可以监听的  热启动  热启动  热启动的阶段和状态都是可监听的，不做过多介绍。
应用程序的状态 启动程序 willFinishLaunchingWithOptions didFinishLaunchingWithOptions applicationDidBecomeActive 按下home键 applicationWillResignActive applicationDidEnterBackground 双击home键，再打开程序 applicationWillEnterForeground applicationDidBecomeActive 简单理解编译过程 应用程序加载过程中会依赖很多底层库，这些底层库其实就是可执行的代码的二进制，被操作系统写入到内存。  编译过程 
静态库 比如： .a, .lib 在链接阶段，会将汇编生成的目标与引用的库一起链接打包到可执行文件中。  静态库 
动态库 比如： framework，.so, .dll，UIKIT.framework， libsystem， libdispatch，libobjc 动态库根据需要编译，动态加载，在运行时才被载入，节约资源，减小体积。  动态库 
快速定位核心源码入口   main函数，断点堆栈（Debug/Debug Workflow/Always Show Disassembly 开启汇编Debug）可以看到是最早是：dyld的start:  main断点'><title>iOS应用程序加载</title>

<link rel='canonical' href='https://wangmingyou.github.io/p/ios-app-launch/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='iOS应用程序加载'>
<meta property='og:description' content='iOS应用程序加载 前言 这篇文章的核心目的是跟着苹果源码，深度学习并理解iOS APP启动过程。
基础概念 冷启动  冷启动 
 注意：在日常开发或测试的时候为了，触发冷启动状态，会手动kill app，然后点击启动。这种情况下的冷启动可能会与上述冷启动过程的步骤稍微少些，可以配合Instrument调试验证（这个在文章结尾会做介绍）。因此通常如果要模拟更真实全面的冷启动，在kill app后，再打开/并稍微使用几个其他app。
 通常说的启动，也是指的冷启动；启动优化大部分也是做冷启动部分的性能优化 暂且可以把冷启动分为几个阶段：
 T1: main之前，加载App可执行文件到内存，然后执行一系列的加载&amp;amp;链接等工作，最后执行到main()函数 T2: main之后，didFinishLaunching之前，这部分开发是可以监听到的 T3: didFinishLaunching之后，启动页面出现之前，也是可以监听的  热启动  热启动  热启动的阶段和状态都是可监听的，不做过多介绍。
应用程序的状态 启动程序 willFinishLaunchingWithOptions didFinishLaunchingWithOptions applicationDidBecomeActive 按下home键 applicationWillResignActive applicationDidEnterBackground 双击home键，再打开程序 applicationWillEnterForeground applicationDidBecomeActive 简单理解编译过程 应用程序加载过程中会依赖很多底层库，这些底层库其实就是可执行的代码的二进制，被操作系统写入到内存。  编译过程 
静态库 比如： .a, .lib 在链接阶段，会将汇编生成的目标与引用的库一起链接打包到可执行文件中。  静态库 
动态库 比如： framework，.so, .dll，UIKIT.framework， libsystem， libdispatch，libobjc 动态库根据需要编译，动态加载，在运行时才被载入，节约资源，减小体积。  动态库 
快速定位核心源码入口   main函数，断点堆栈（Debug/Debug Workflow/Always Show Disassembly 开启汇编Debug）可以看到是最早是：dyld的start:  main断点'>
<meta property='og:url' content='https://wangmingyou.github.io/p/ios-app-launch/'>
<meta property='og:site_name' content='YoyoWong'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='iOS' /><meta property='article:published_time' content='2022-03-25T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2022-03-25T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="iOS应用程序加载">
<meta name="twitter:description" content="iOS应用程序加载 前言 这篇文章的核心目的是跟着苹果源码，深度学习并理解iOS APP启动过程。
基础概念 冷启动  冷启动 
 注意：在日常开发或测试的时候为了，触发冷启动状态，会手动kill app，然后点击启动。这种情况下的冷启动可能会与上述冷启动过程的步骤稍微少些，可以配合Instrument调试验证（这个在文章结尾会做介绍）。因此通常如果要模拟更真实全面的冷启动，在kill app后，再打开/并稍微使用几个其他app。
 通常说的启动，也是指的冷启动；启动优化大部分也是做冷启动部分的性能优化 暂且可以把冷启动分为几个阶段：
 T1: main之前，加载App可执行文件到内存，然后执行一系列的加载&amp;amp;链接等工作，最后执行到main()函数 T2: main之后，didFinishLaunching之前，这部分开发是可以监听到的 T3: didFinishLaunching之后，启动页面出现之前，也是可以监听的  热启动  热启动  热启动的阶段和状态都是可监听的，不做过多介绍。
应用程序的状态 启动程序 willFinishLaunchingWithOptions didFinishLaunchingWithOptions applicationDidBecomeActive 按下home键 applicationWillResignActive applicationDidEnterBackground 双击home键，再打开程序 applicationWillEnterForeground applicationDidBecomeActive 简单理解编译过程 应用程序加载过程中会依赖很多底层库，这些底层库其实就是可执行的代码的二进制，被操作系统写入到内存。  编译过程 
静态库 比如： .a, .lib 在链接阶段，会将汇编生成的目标与引用的库一起链接打包到可执行文件中。  静态库 
动态库 比如： framework，.so, .dll，UIKIT.framework， libsystem， libdispatch，libobjc 动态库根据需要编译，动态加载，在运行时才被载入，节约资源，减小体积。  动态库 
快速定位核心源码入口   main函数，断点堆栈（Debug/Debug Workflow/Always Show Disassembly 开启汇编Debug）可以看到是最早是：dyld的start:  main断点">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/ios/" >
                iOS
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/ios-app-launch/">iOS应用程序加载</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Mar 25, 2022</time>
            </div>
        
        
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                <time class="article-time--published">YoyoWong</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    7 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h1 id="ios应用程序加载">iOS应用程序加载</h1>
<h2 id="前言">前言</h2>
<p>这篇文章的核心目的是跟着苹果源码，深度学习并理解iOS APP启动过程。</p>
<h2 id="基础概念">基础概念</h2>
<h3 id="冷启动">冷启动</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 512; 
			flex-basis: 1229px"
	>
	<a href="/p/ios-app-launch/assets/1.png" data-size="2418x472">
		<img src="/p/ios-app-launch/assets/1.png"
			width="2418"
			height="472"
			srcset="/p/ios-app-launch/assets/1_hu92fafcac3c6ae833f41ecd2f3be33f6b_115318_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/1_hu92fafcac3c6ae833f41ecd2f3be33f6b_115318_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="冷启动">
	</a>
	
	<figcaption>冷启动</figcaption>
	
</figure></p>
<blockquote>
<p>注意：在日常开发或测试的时候为了，触发冷启动状态，会手动kill app，然后点击启动。这种情况下的冷启动可能会与上述冷启动过程的步骤稍微少些，可以配合Instrument调试验证（这个在文章结尾会做介绍）。因此通常如果要模拟更真实全面的冷启动，在kill app后，再打开/并稍微使用几个其他app。</p>
</blockquote>
<p>通常说的启动，也是指的冷启动；启动优化大部分也是做冷启动部分的性能优化
暂且可以把冷启动分为几个阶段：</p>
<ul>
<li>T1: main之前，加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行到main()函数</li>
<li>T2: main之后，didFinishLaunching之前，这部分开发是可以监听到的</li>
<li>T3: didFinishLaunching之后，启动页面出现之前，也是可以监听的</li>
</ul>
<h3 id="热启动">热启动</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 859; 
			flex-basis: 2063px"
	>
	<a href="/p/ios-app-launch/assets/2.png" data-size="1926x224">
		<img src="/p/ios-app-launch/assets/2.png"
			width="1926"
			height="224"
			srcset="/p/ios-app-launch/assets/2_hucaca5c4dc98265c0f485d22c21d03661_58729_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/2_hucaca5c4dc98265c0f485d22c21d03661_58729_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="热启动">
	</a>
	
	<figcaption>热启动</figcaption>
	
</figure>
热启动的阶段和状态都是可监听的，不做过多介绍。</p>
<h3 id="应用程序的状态">应用程序的状态</h3>
<pre tabindex="0"><code>启动程序
willFinishLaunchingWithOptions
didFinishLaunchingWithOptions
applicationDidBecomeActive

按下home键
applicationWillResignActive
applicationDidEnterBackground

双击home键，再打开程序
applicationWillEnterForeground
applicationDidBecomeActive
</code></pre><h2 id="简单理解编译过程">简单理解编译过程</h2>
<p>应用程序加载过程中会依赖很多底层库，这些底层库其实就是可执行的代码的二进制，被操作系统写入到内存。
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 127; 
			flex-basis: 306px"
	>
	<a href="/p/ios-app-launch/assets/3.png" data-size="1140x894">
		<img src="/p/ios-app-launch/assets/3.png"
			width="1140"
			height="894"
			srcset="/p/ios-app-launch/assets/3_hu67d4812b847fdce77853d4cb4e5a5013_76781_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/3_hu67d4812b847fdce77853d4cb4e5a5013_76781_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="编译过程">
	</a>
	
	<figcaption>编译过程</figcaption>
	
</figure></p>
<h3 id="静态库">静态库</h3>
<p>比如： .a, .lib
在链接阶段，会将汇编生成的目标与引用的库一起链接打包到可执行文件中。
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 268; 
			flex-basis: 644px"
	>
	<a href="/p/ios-app-launch/assets/4.png" data-size="978x364">
		<img src="/p/ios-app-launch/assets/4.png"
			width="978"
			height="364"
			srcset="/p/ios-app-launch/assets/4_hu1c2d4a19039aae8429bd70c683f742a5_26183_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/4_hu1c2d4a19039aae8429bd70c683f742a5_26183_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="静态库">
	</a>
	
	<figcaption>静态库</figcaption>
	
</figure></p>
<h3 id="动态库">动态库</h3>
<p>比如： framework，.so, .dll，UIKIT.framework， libsystem， libdispatch，libobjc
动态库根据需要编译，动态加载，在运行时才被载入，节约资源，减小体积。
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 200; 
			flex-basis: 481px"
	>
	<a href="/p/ios-app-launch/assets/5.png" data-size="1144x570">
		<img src="/p/ios-app-launch/assets/5.png"
			width="1144"
			height="570"
			srcset="/p/ios-app-launch/assets/5_hua8c381f0defb05b80157695819fc4b1b_48348_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/5_hua8c381f0defb05b80157695819fc4b1b_48348_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="动态库">
	</a>
	
	<figcaption>动态库</figcaption>
	
</figure></p>
<h2 id="快速定位核心源码入口">快速定位核心源码入口</h2>
<ol>
<li>
<p>main函数，断点堆栈（Debug/Debug Workflow/Always Show Disassembly 开启汇编Debug）可以看到是最早是：dyld的start:
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 160; 
			flex-basis: 384px"
	>
	<a href="/p/ios-app-launch/assets/6.png" data-size="1280x800">
		<img src="/p/ios-app-launch/assets/6.png"
			width="1280"
			height="800"
			srcset="/p/ios-app-launch/assets/6_hu280aaf2196919c2e86fe04b216ba84b7_436805_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/6_hu280aaf2196919c2e86fe04b216ba84b7_436805_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="main断点">
	</a>
	
	<figcaption>main断点</figcaption>
	
</figure></p>
</li>
<li>
<p>根据已有常识，还有一个特殊方法 + load（或+ (void)initialize）方法，在此断点
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 160; 
			flex-basis: 384px"
	>
	<a href="/p/ios-app-launch/assets/7.png" data-size="1280x800">
		<img src="/p/ios-app-launch/assets/7.png"
			width="1280"
			height="800"
			srcset="/p/ios-app-launch/assets/7_hu280aaf2196919c2e86fe04b216ba84b7_517556_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/7_hu280aaf2196919c2e86fe04b216ba84b7_517556_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="load断点">
	</a>
	
	<figcaption>load断点</figcaption>
	
</figure></p>
</li>
<li>
<p>初探结论：_dyld_start  -&gt; +load  -&gt; main -&gt; +initialize</p>
</li>
<li>
<p>接下来就跟着dyld源码 初步搜索 _dyld_start</p>
</li>
</ol>
<blockquote>
<p>源码学习小Tips</p>
<ol>
<li>OC 底层是 C/C++/汇编 所以源码常见搜索技巧：<em>XXXX(或者删除</em>)   XXXX::    ::XXXX  XXXX(</li>
<li>主逻辑很可能在 if else 判断 ； while / do-while； for 里面</li>
<li>通过返回值 - 定位核心逻辑 （尤其汇编，重点关注bl）</li>
<li>看官方源码，多关注有注释的地方；</li>
<li>抓主干，跳过类似 check / if-return逻辑；跳过预编译非主架构逻辑（ios架构：arm64）</li>
</ol>
</blockquote>
<p>搜索__dyld_start,只看arm64下的
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 160; 
			flex-basis: 384px"
	>
	<a href="/p/ios-app-launch/assets/8.png" data-size="3072x1920">
		<img src="/p/ios-app-launch/assets/8.png"
			width="3072"
			height="1920"
			srcset="/p/ios-app-launch/assets/8_hub2c0b415f802ff7e14d3d745e8f94a46_1136033_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/8_hub2c0b415f802ff7e14d3d745e8f94a46_1136033_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="dyld_start汇编入口">
	</a>
	
	<figcaption>dyld_start汇编入口</figcaption>
	
</figure>
看不懂汇编没关系，看后面的注释，大概能明白其含义，直到出现bl跳转，再结合其注释，基本定位到核心代码：</p>
<pre tabindex="0"><code>// call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)
	bl	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm
	mov	x16,x0                  // save entry point address in x16
</code></pre><blockquote>
<p>搜索 <code>dyldbootstrap::star</code>，<code>::start</code> 未果，猜测C方法，搜索<code>start(</code> ，确定<code>dyld - star</code> 最终入口函数。</p>
</blockquote>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 160; 
			flex-basis: 384px"
	>
	<a href="/p/ios-app-launch/assets/9.png" data-size="3072x1920">
		<img src="/p/ios-app-launch/assets/9.png"
			width="3072"
			height="1920"
			srcset="/p/ios-app-launch/assets/9_hub2c0b415f802ff7e14d3d745e8f94a46_1000667_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/9_hub2c0b415f802ff7e14d3d745e8f94a46_1000667_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="dyld_star最终入口函数">
	</a>
	
	<figcaption>dyld_star最终入口函数</figcaption>
	
</figure>
这样首先可以确认最终入口方法<code>uintptr_t start(...)</code></p>
<h3 id="入口函数-uintptr_t-start">入口函数 uintptr_t start(&hellip;)</h3>
<pre tabindex="0"><code>intptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], 
				intptr_t slide, const struct macho_header* dyldsMachHeader,
				uintptr_t* startGlue)
{
			// rebaseDyldIfNeeded
    	// mach_init
    	// apple_guard_setup
    
    	return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);
}
</code></pre><h3 id="核心函数-dyld_main">核心函数 dyld::_main</h3>
<pre tabindex="0"><code>uintptr_t _main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide,
                int argc, const char* argv[], const char* envp[], const char* apple[], 
                uintptr_t* startGlue) {
    // settupEnv 环境变量的相关处理
        ...
        checkEnvironmentVariables(envp);
		defaultUninitializedFallbackPaths(envp);
        ...
    // load shared cache（共享缓存处理）
        ...
        // load shared cache
        checkSharedRegionDisable(...);
        mapSharedCache();
        ...
            
    // 将dyld加到UUID列表
        ...
        // add dyld itself to UUID list
		addDyldImageToUUIDList();
        ...
    // ...
    [1]reloadAllImages:
        [1.1]mainExecutable ... (实例化主程序)
    
    ...
    // [1.2]load any inserted libraries (加载任何插入动态库)
    if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) {
        for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) 
            loadInsertedDylib(*lib);
    }
    ...
        
    // [1.3.1]link main executable (链接库)
    link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);
    ...
    // [1.3.2]link any inserted libraries
    
    // [2]run all initializers (运行所有初始化程序)
	initializeMainExecutable();
    
    // [3]notify any montoring proccesses that this process is about to enter main()
    (通知监听dyld-main)
    ...
    notifyMonitoringDyldMain();
}
</code></pre><h2 id="dyld核心源码流程">dyld核心源码流程</h2>
<h3 id="1-reloadallimages">1. reloadAllImages</h3>
<h4 id="11-实例化主程序">1.1 实例化主程序</h4>
<pre tabindex="0"><code>static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)
{
	// try mach-o loader
	if ( isCompatibleMachO((const uint8_t*)mh, path) ) {
		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);
		addImage(image);
		return (ImageLoaderMachO*)image;
	}
	...
}

// create image for main executable
ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)
{
   ....
	bool compressed;
	unsigned int segCount; // 段的数量
	unsigned int libCount; // lib库的数量
	...
	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);
	// instantiate concrete class based on content of load commands
	...
}
</code></pre><ol>
<li><code>instantiateFromLoadedImage</code> -&gt; <code>instantiateMainExecutable</code> -&gt; <code>sniffLoadCommands</code></li>
<li><code>addImage</code></li>
</ol>
<h4 id="12-加载任何插入动态库">1.2 加载任何插入动态库</h4>
<p>在uintptr_t _main(&hellip;) 函数有如下核心流程</p>
<pre tabindex="0"><code>// load any inserted libraries
if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) {
	for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) 
		loadInsertedDylib(*lib);
}
</code></pre><p>loadInsertedDylib</p>
<pre tabindex="0"><code>// 使用动态库注入代码可以参考这个
static void loadInsertedDylib(const char* path)
{
	ImageLoader* image = NULL;
	unsigned cacheIndex;
	try {
		LoadContext context;
        context.useSearchPaths		= false;
		...
		image = load(path, context, cacheIndex);
	}
	catch (const char* msg) {
		...
    }
}
</code></pre><p>这样就完成了将lib库以镜像文件的形式加载进来了，并生成对应的Image，只需要在合适的地方进行映射即可。</p>
<h4 id="13-链接库">1.3 链接库</h4>
<p>在uintptr_t _main(&hellip;) 函数有如下核心流程</p>
<pre tabindex="0"><code>// link any inserted libraries
// do this after linking main executable so that any dylibs pulled in by inserted 
// dylibs (e.g. libSystem) will not be in front of dylibs the program uses
if ( sInsertedDylibCount &gt; 0 ) {
    for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) {
        ImageLoader* image = sAllImages[i+1];
        link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);
        image-&gt;setNeverUnloadRecursive();
    }
    // only INSERTED libraries can interpose
    // register interposing info after all inserted libraries are bound so chaining works
    for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) {
        ImageLoader* image = sAllImages[i+1];
        image-&gt;registerInterposing(gLinkContext);
    }
}

...
// Bind and notify for the inserted images now interposing has been registered
if ( sInsertedDylibCount &gt; 0 ) {
    for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) {
        ImageLoader* image = sAllImages[i+1];
        image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true);
    }
}
</code></pre><h5 id="1-遍历-link-images">1. 遍历 link images</h5>
<ul>
<li>根据loadInsertedDylib 后的 sInsertedDylibCount，遍历已经加载的动态库；</li>
<li>根据ImageLoaderMachO::instantiateMainExecutable -&gt; sAllImages遍历执行 ImageLoader* image = sAllImages[i+1];；</li>
<li>link image
<ul>
<li>递归操作</li>
</ul>
</li>
</ul>
<h5 id="2递归插入加载">2.递归插入/加载</h5>
<pre tabindex="0"><code>void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)
{
	...
    // 递归加载
	this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);
	context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);
    ...
	// 递归刷新依赖库的层级
	this-&gt;recursiveUpdateDepth(context.imageCount());

    // 符号绑定
	__block uint64_t t2, t3, t4, t5;
	{
        ...
		this-&gt;recursiveRebase(context);
		context.notifyBatch(dyld_image_state_rebased, false);

		t3 = mach_absolute_time();
		if ( !context.linkingMainExecutable )
			this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);

		t4 = mach_absolute_time();
		if ( !context.linkingMainExecutable )
			this-&gt;weakBind(context);
		t5 = mach_absolute_time();
	}
    ...
	this-&gt;recursiveGetDOFSections(context, dofs);
	context.registerDOFs(dofs);
	uint64_t t7 = mach_absolute_time();	
	// interpose any dynamically loaded images
	if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) {
		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);
		this-&gt;recursiveApplyInterposing(context);
	}
    ...
}
</code></pre><h3 id="2-运行所有初始化程序---run-all-initializers">2. 运行所有初始化程序 - run all initializers</h3>
<ol>
<li>执行所有插入的dylib执行初始化</li>
<li>执行主程序初始化</li>
</ol>
<pre tabindex="0"><code>void initializeMainExecutable()
{
    ....
	// run initialzers for any inserted dylibs
	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];
	initializerTimes[0].count = 0;
	const size_t rootCount = sImageRoots.size();
	if ( rootCount &gt; 1 ) {
		for(size_t i=1; i &lt; rootCount; ++i) {
			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]);
		}
	}
	// run initializers for main executable and everything it brings up 
	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]);
	
	...
}
</code></pre><h4 id="21-runinitializers">2.1 runInitializers</h4>
<pre tabindex="0"><code>void ImageLoader::runInitializers(const LinkContext&amp; context, InitializerTimingList&amp; timingInfo)
{
	...
	processInitializers(context, thisThread, timingInfo, up);
	context.notifyBatch(dyld_image_state_initialized, false);
	...
}

void ImageLoader::processInitializers(const LinkContext&amp; context, mach_port_t thisThread,
									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)
{
    // 初始化准备
    ...
	// Calling recursive init on all images in images list, building a new list of
	// uninitialized upward dependencies.
    // 遍历初始化
	for (uintptr_t i=0; i &lt; images.count; ++i) {
        // 递归，一个个初始化
		images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);
	}
    ...
}
</code></pre><h5 id="1-recursiveinitialization">1. recursiveInitialization</h5>
<p><code>notifySingle</code>，通知<code>dyld_image_states</code>状态的改变
<code>doInitialization</code>， 完成初始化</p>
<pre tabindex="0"><code>void ImageLoader::recursiveInitialization(const LinkContext&amp; context, mach_port_t this_thread, const char* pathToInitialize,
										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)
{
	recursive_lock lock_info(this_thread);
	recursiveSpinLock(lock_info);

	if ( fState &lt; dyld_image_state_dependents_initialized-1 ) {
		uint8_t oldState = fState;
		// break cycles
		fState = dyld_image_state_dependents_initialized-1;
		try {
			// initialize lower level libraries first
			....
			
			// let objc know we are about to initialize this image
            ....
			context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo);
			
			// initialize this image
			bool hasInitializers = this-&gt;doInitialization(context);
            // let anyone know we finished initializing this image
            ....
			context.notifySingle(dyld_image_state_initialized, this, NULL);
			....
		}
        ...
	}
	recursiveSpinUnLock();
}
</code></pre><h5 id="2-doinitialization">2. doInitialization</h5>
<pre tabindex="0"><code>bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)
{
    ....
	// mach-o has -init and static initializers
	doImageInit(context);
	doModInitFunctions(context);
    ....
}

void ImageLoaderMachO::doModInitFunctions(const LinkContext&amp; context)
{
	if ( fHasInitializers ) {
		const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;
		const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)];
		const struct load_command* cmd = cmds;
		for (uint32_t i = 0; i &lt; cmd_count; ++i) {
			if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) {
				for (const struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) {
					const uint8_t type = sect-&gt;flags &amp; SECTION_TYPE;
					...
                    Initializer* inits = (Initializer*)(sect-&gt;addr + fSlide);
                    ...
                    for (size_t j=0; j &lt; count; ++j) {
                        Initializer func = inits[j];
                        ....
                    }
                    ....
				}
			}
			cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);
		}
	}
}
</code></pre><h5 id="3-notifysingle">3. notifySingle</h5>
<p>这里<code>(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader())</code>;就是获取函数指针地址，执行对应的函数。</p>
<pre tabindex="0"><code>static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)
{
   //dyld::log(&quot;notifySingle(state=%d, image=%s)\n&quot;, state, image-&gt;getPath());
   ....
   if ( state == dyld_image_state_mapped ) {
   	....
   }
   if ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != NULL) &amp;&amp; image-&gt;notifyObjC() ) {
   	....
       (*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());
   	....
   }
   // mach message csdlc about dynamically unloaded images
   if ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) {
   	....
   	notifyMonitoringDyld(true, 1, loadAddress, loadPath);
   }
}
</code></pre><p>所以到此，可以看出<code>sNotifyObjCInit</code>是一个c函数指针地址，dyld通过获取到<code>libobjc</code>函数指针，可以执行到<code>libobjc</code>里面。
在dyld源码中全局搜索<code>sNotifyObjCInit</code>,可以找到<code>sNotifyObjCInit</code>赋值的地方发生在<code>registerObjCNotifiers</code></p>
<pre tabindex="0"><code>void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)
{
	// record functions to call
	sNotifyObjCMapped	= mapped;
	sNotifyObjCInit		= init;
	sNotifyObjCUnmapped = unmapped;
    ...
	// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)
	for (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) {
		ImageLoader* image = *it;
		if ( (image-&gt;getState() == dyld_image_state_initialized) &amp;&amp; image-&gt;notifyObjC() ) {
			dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0);
			(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());
		}
	}
    ...
}
void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,
                                _dyld_objc_notify_init      init,
                                _dyld_objc_notify_unmapped  unmapped)
{
	dyld::registerObjCNotifiers(mapped, init, unmapped);
}
</code></pre><p>进一步在dyld中查找<code>registerObjCNotifiers</code>,<code>_dyld_objc_notify_register</code>，可以分析出，这个register函数是extern，并不是在dyld发起调用的。至于到底在哪里调用，后面会详细说明。</p>
<h3 id="3-回调监听">3. 回调监听</h3>
<h4 id="1-猜测流程">1. 猜测流程</h4>
<p>到此可以猜测，<code>dyld -&gt; libobjc</code>  的方式是通过这种函数指针的方式进行通信, 应该是<code>libobjc</code>在某个地方进行了<code>registerObjCNotifiers</code>，这样<code>dyld start</code>后，根据上述流程，即可跳转到<code>libobjc</code>。这种不同库之间 <code>register-notify</code>的方式进行通信的完成代码调用的，明显代码在一个库里面一行行跟进代码是行不通的。所以接下来需要捋一下思路。</p>
<h4 id="2-提出疑问">2. 提出疑问</h4>
<p>那么现在有两个疑问：</p>
<ol>
<li>OC怎么将自己的函数指针传给dyld的呢？</li>
<li>OC又是在什么时候完成注册的呢？</li>
<li>OC-dyld之间的相互通信是如何配合的呢？</li>
</ol>
<h2 id="libobjc-启动核心源码分析">libobjc 启动核心源码分析</h2>
<p>直接从苹果官网下载libobjc源码。</p>
<h3 id="找到-_dyld_objc_notify_register-入口">找到 _dyld_objc_notify_register 入口</h3>
<p>在<code>dyld</code>源码分析中，能看出<code>libobjc</code>是通过 调用<code>_dyld_objc_notify_register</code>来完成注册的。在<code>libobjc</code>源码中搜索<code>_dyld_objc_notify_register</code>,发现其在<code>_objc_init</code>里调用，完成的向<code>dyld</code>注册函数。</p>
<pre tabindex="0"><code>void _objc_init(void)
{
    ....
    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);
    ....
}

</code></pre><p>通过<code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image) </code>可以快速解答了前面问题1（什么时候注册）和问题2（如何注册）。 并且我们也能看到<code>dyld</code>里面的<code>sNotifyObjCInit</code>即是<code>libobjc</code>的<code>load_images</code>函数，<code>sNotifyObjCMapped</code>是<code>map_images</code>函数。
现在又有新的问题产生了，虽然明确了<code>libobjc</code>向<code>dyld</code>注册函数发生在<code>_objc_init</code>里面，但是<code>_objc_init</code>到底什么时候触发的还是不知道。</p>
<h3 id="build--run-libobjc">build &amp; run libobjc</h3>
<p>然后根据自己的Xcode和系统版本，将libobjc源码build，并run起来。这里就不做详细介绍）</p>
<blockquote>
<p><a class="link" href="https://wangmy.github.io/p/open_source/"  target="_blank" rel="noopener"
    >objc818-canrun for Bigsur, objc838-canrun for Monterey</a> 在这里可以自己根据当前环境找一个源码尝试跑一个。</p>
</blockquote>
<blockquote>
<p>简单的思路就是在github上把源码down下来，然后直接build，那种找不到符号的报错直接先注释，找不到文件的去apple的open source搜索下，如果找到了，就添加到自己的工程下面。基本这样操作完了，就没error了，然后新建一个target, 将objc库添加到target的Dependencies 里面。如下图所示。</p>
</blockquote>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 159; 
			flex-basis: 383px"
	>
	<a href="/p/ios-app-launch/assets/10.jpg" data-size="1500x938">
		<img src="/p/ios-app-launch/assets/10.jpg"
			width="1500"
			height="938"
			srcset="/p/ios-app-launch/assets/10_hu15c7c349cd219dc700813f6d454ddd97_192988_480x0_resize_q75_box.jpg 480w, /p/ios-app-launch/assets/10_hu15c7c349cd219dc700813f6d454ddd97_192988_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="libobjc源码">
	</a>
	
	<figcaption>libobjc源码</figcaption>
	
</figure></p>
<p>为了明确<code>_objc_init</code>的调用时机，简单的思路就是在<code>_objc_init</code>里面加一个断点，看堆栈。</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 159; 
			flex-basis: 383px"
	>
	<a href="/p/ios-app-launch/assets/11.jpg" data-size="1500x938">
		<img src="/p/ios-app-launch/assets/11.jpg"
			width="1500"
			height="938"
			srcset="/p/ios-app-launch/assets/11_hu15c7c349cd219dc700813f6d454ddd97_406892_480x0_resize_q75_box.jpg 480w, /p/ios-app-launch/assets/11_hu15c7c349cd219dc700813f6d454ddd97_406892_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="_objc_init堆栈">
	</a>
	
	<figcaption>_objc_init堆栈</figcaption>
	
</figure></p>
<h3 id="确认基础流程">确认基础流程</h3>
<p><code>dyld</code> -&gt;<code>libsystem</code> -&gt;<code>libdispatch</code> -&gt;<code>libobjc</code> -&gt;<code>_objc_init</code></p>
<p>从打印的详细堆栈信息看，dyld<code>_dyld_start</code>-&gt; &hellip;. -&gt;<code>ImageLoaderMachO::doModInitFunction</code>这个过程的流程正好跟前面dyld 源码分析的过程吻合上了。后面是<code>libSystem.B.dylib libSystem_initializer</code>(猜测这个过程应该是<code>doModInitFunction</code>里面调起的) -&gt;<code>libdispatch</code>-&gt;<code>libobjc</code></p>
<p>在<code>dyld</code>中的搜索<code>image-&gt;getRealPath()</code> 基本可以确定<code>libobjc</code>注册的函数的调用时机。在<code>notifyBatchPartial</code>和<code>notifySingle</code>根据<code>dyld_image_states</code>触发不同的注册函数。</p>
<blockquote>
<p>dyld_image_state_bound 触发 libjobcmap_images
dyld_image_state_initialized 触发libobjc load_images</p>
</blockquote>
<h2 id="验证流程---配合libsytem源码libdispatch源码">验证流程 - 配合libSytem源码，libdispatch源码</h2>
<p>在前面<code>dyld</code>已经分析到了<code>doModInitFunctions</code>里面</p>
<h3 id="dyld-初始化必须确保先完成-libsystem-初始化">dyld 初始化必须确保先完成 libSystem 初始化</h3>
<p>回到<code>dyld</code> 的<code>doModInitFunctions</code>的部分代码</p>
<pre tabindex="0"><code>....
Initializer* inits = (Initializer*)(sect-&gt;addr + fSlide);
....
Initializer func = inits[j];
// &lt;rdar://problem/8543820&amp;9228031&gt; verify initializers are in image
if ( ! this-&gt;containsAddress(stripPointer((void*)func)) ) {
  dyld::throwf(&quot;initializer function %p not in mapped image for %s\n&quot;, func, this-&gt;getPath());
}
if ( ! dyld::gProcessInfo-&gt;libSystemInitialized ) {
  // &lt;rdar://problem/17973316&gt; libSystem initializer must run first
  const char* installPath = getInstallPath();
  if ( (installPath == NULL) || (strcmp(installPath, LIBSYSTEM_DYLIB_PATH) != 0) )
    dyld::throwf(&quot;initializer in image (%s) that does not link with libSystem.dylib\n&quot;, this-&gt;getPath());
}
if ( context.verboseInit )
  dyld::log(&quot;dyld: calling initializer function %p in %s\n&quot;, func, this-&gt;getPath());
bool haveLibSystemHelpersBefore = (dyld::gLibSystemHelpers != NULL);
{
  dyld3::ScopedTimer(DBG_DYLD_TIMING_STATIC_INITIALIZER, (uint64_t)fMachOData, (uint64_t)func, 0);
  func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);
}
</code></pre><p>可以看到<code>dyld</code>确实要走并确定先到<code>libSystem</code>的<code>initializer</code></p>
<h3 id="libsytem-initializer">libSytem initializer</h3>
<p>再到libSystem源码中搜索initializer，确定入口 libSystem_initializer,接下来就是一个个方法跟踪查看，最终可以看出流程为
libSystem_initializer-&gt; libdispatch_init</p>
<h3 id="libdispatch_init">libdispatch_init</h3>
<p>到libdispatch源码中常规分析思路，最终流程为
libdispatch_init-&gt; _os_object_init-&gt; _objc_init
到这里，通过源码也验证了 上述堆栈的流程。</p>
<h2 id="启动完整流程">启动完整流程</h2>
<h3 id="简化流程图">简化流程图</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 186; 
			flex-basis: 447px"
	>
	<a href="/p/ios-app-launch/assets/12.jpg" data-size="1722x924">
		<img src="/p/ios-app-launch/assets/12.jpg"
			width="1722"
			height="924"
			srcset="/p/ios-app-launch/assets/12_hu15c7c349cd219dc700813f6d454ddd97_132632_480x0_resize_q75_box.jpg 480w, /p/ios-app-launch/assets/12_hu15c7c349cd219dc700813f6d454ddd97_132632_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="简化流程图">
	</a>
	
	<figcaption>简化流程图</figcaption>
	
</figure></p>
<h3 id="详细流程图">详细流程图</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 165; 
			flex-basis: 397px"
	>
	<a href="/p/ios-app-launch/assets/13.png" data-size="2736x1654">
		<img src="/p/ios-app-launch/assets/13.png"
			width="2736"
			height="1654"
			srcset="/p/ios-app-launch/assets/13_hu7d64730783b5ce8da429aff9cb4efd2b_420926_480x0_resize_box_3.png 480w, /p/ios-app-launch/assets/13_hu7d64730783b5ce8da429aff9cb4efd2b_420926_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="详细流程图">
	</a>
	
	<figcaption>详细流程图</figcaption>
	
</figure></p>
<h2 id="实际应用">实际应用</h2>
<h3 id="main之前---调试--监测">main之前 - 调试 &amp; 监测</h3>
<h4 id="1-xcode打印pre-main的时间开发环境xcode-dyld_print_statics--1">1. Xcode打印pre-main的时间：开发环境Xcode DYLD_PRINT_STATICS = 1</h4>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 368; 
			flex-basis: 885px"
	>
	<a href="/p/ios-app-launch/assets/14.jpg" data-size="509x138">
		<img src="/p/ios-app-launch/assets/14.jpg"
			width="509"
			height="138"
			srcset="/p/ios-app-launch/assets/14_hu15c7c349cd219dc700813f6d454ddd97_42452_480x0_resize_q75_box.jpg 480w, /p/ios-app-launch/assets/14_hu15c7c349cd219dc700813f6d454ddd97_42452_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="实际应用1">
	</a>
	
	<figcaption>实际应用1</figcaption>
	
</figure></p>
<ol>
<li>dylid loading time:动态库加载时间，载入动态库,尽可能使用系统库,自定义库，最好不要大于6个（apple推荐）</li>
<li>rebase（修正偏移指针 ASLR-修复内部指针） / binding time （外部符号绑定）:（fishhook）</li>
<li>Objc set up time， 减少OC类，有统计2万个oc类增加800毫秒，swift比OC的效率更高，删除弃用的类（找工具检测）</li>
<li>initializer time load方法 懒加载，尽量放在initialize 去调用</li>
<li>slowest initializer:最慢的几个库的时间</li>
<li>libsystem:</li>
</ol>
<h4 id="2-instrument---systemtrace--timeprofiler">2. Instrument - SystemTrace / TimeProfiler</h4>
<p>会记录启动的一些信息</p>
<h4 id="3-xcode配置linkmap拿到linkmap文件分析">3. Xcode配置LinkMap，拿到LinkMap文件，分析</h4>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 244; 
			flex-basis: 587px"
	>
	<a href="/p/ios-app-launch/assets/15.jpg" data-size="526x215">
		<img src="/p/ios-app-launch/assets/15.jpg"
			width="526"
			height="215"
			srcset="/p/ios-app-launch/assets/15_hu15c7c349cd219dc700813f6d454ddd97_25305_480x0_resize_q75_box.jpg 480w, /p/ios-app-launch/assets/15_hu15c7c349cd219dc700813f6d454ddd97_25305_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="实际应用2">
	</a>
	
	<figcaption>实际应用2</figcaption>
	
</figure></p>
<h4 id="4-其他12不推荐开拓思路">4. 其他（1，2不推荐，开拓思路）</h4>
<ol>
<li>定时抓取主线程上的方法调用堆栈（backtrace），计算一段时间里各个方法的耗时。</li>
<li>hook objc_msgSend 方法进行hook，掌握所有方法的执行耗时 （libffi, facebook fishhook）</li>
<li>在启动的相关时机插入自定义的动态库，配合技术埋点</li>
<li>Apple-Metrics（可自定义） 配合分析线上</li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/ios/">iOS</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/open_source/">
        
        

        <div class="article-details">
            <h2 class="article-title">源码学习</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/objc_msgsend/">
        
        

        <div class="article-details">
            <h2 class="article-title">消息发送源码学习</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/super-class-study/">
        
        

        <div class="article-details">
            <h2 class="article-title">分析 在OC中 [self class] 与 [super class] 的区别</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2018 - 
        
        2022 YoyoWong
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#前言">前言</a></li>
    <li><a href="#基础概念">基础概念</a>
      <ol>
        <li><a href="#冷启动">冷启动</a></li>
        <li><a href="#热启动">热启动</a></li>
        <li><a href="#应用程序的状态">应用程序的状态</a></li>
      </ol>
    </li>
    <li><a href="#简单理解编译过程">简单理解编译过程</a>
      <ol>
        <li><a href="#静态库">静态库</a></li>
        <li><a href="#动态库">动态库</a></li>
      </ol>
    </li>
    <li><a href="#快速定位核心源码入口">快速定位核心源码入口</a>
      <ol>
        <li><a href="#入口函数-uintptr_t-start">入口函数 uintptr_t start(&hellip;)</a></li>
        <li><a href="#核心函数-dyld_main">核心函数 dyld::_main</a></li>
      </ol>
    </li>
    <li><a href="#dyld核心源码流程">dyld核心源码流程</a>
      <ol>
        <li><a href="#1-reloadallimages">1. reloadAllImages</a>
          <ol>
            <li><a href="#11-实例化主程序">1.1 实例化主程序</a></li>
            <li><a href="#12-加载任何插入动态库">1.2 加载任何插入动态库</a></li>
            <li><a href="#13-链接库">1.3 链接库</a></li>
          </ol>
        </li>
        <li><a href="#2-运行所有初始化程序---run-all-initializers">2. 运行所有初始化程序 - run all initializers</a>
          <ol>
            <li><a href="#21-runinitializers">2.1 runInitializers</a></li>
          </ol>
        </li>
        <li><a href="#3-回调监听">3. 回调监听</a>
          <ol>
            <li><a href="#1-猜测流程">1. 猜测流程</a></li>
            <li><a href="#2-提出疑问">2. 提出疑问</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#libobjc-启动核心源码分析">libobjc 启动核心源码分析</a>
      <ol>
        <li><a href="#找到-_dyld_objc_notify_register-入口">找到 _dyld_objc_notify_register 入口</a></li>
        <li><a href="#build--run-libobjc">build &amp; run libobjc</a></li>
        <li><a href="#确认基础流程">确认基础流程</a></li>
      </ol>
    </li>
    <li><a href="#验证流程---配合libsytem源码libdispatch源码">验证流程 - 配合libSytem源码，libdispatch源码</a>
      <ol>
        <li><a href="#dyld-初始化必须确保先完成-libsystem-初始化">dyld 初始化必须确保先完成 libSystem 初始化</a></li>
        <li><a href="#libsytem-initializer">libSytem initializer</a></li>
        <li><a href="#libdispatch_init">libdispatch_init</a></li>
      </ol>
    </li>
    <li><a href="#启动完整流程">启动完整流程</a>
      <ol>
        <li><a href="#简化流程图">简化流程图</a></li>
        <li><a href="#详细流程图">详细流程图</a></li>
      </ol>
    </li>
    <li><a href="#实际应用">实际应用</a>
      <ol>
        <li><a href="#main之前---调试--监测">main之前 - 调试 &amp; 监测</a>
          <ol>
            <li><a href="#1-xcode打印pre-main的时间开发环境xcode-dyld_print_statics--1">1. Xcode打印pre-main的时间：开发环境Xcode DYLD_PRINT_STATICS = 1</a></li>
            <li><a href="#2-instrument---systemtrace--timeprofiler">2. Instrument - SystemTrace / TimeProfiler</a></li>
            <li><a href="#3-xcode配置linkmap拿到linkmap文件分析">3. Xcode配置LinkMap，拿到LinkMap文件，分析</a></li>
            <li><a href="#4-其他12不推荐开拓思路">4. 其他（1，2不推荐，开拓思路）</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
