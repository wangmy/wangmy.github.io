[{"content":"iOS应用程序加载 前言 这篇文章的核心目的是跟着苹果源码，深度学习并理解iOS APP启动过程。\n基础概念 冷启动  注意：在日常开发或测试的时候为了，触发冷启动状态，会手动kill app，然后点击启动。这种情况下的冷启动可能会与上述冷启动过程的步骤稍微少些，可以配合Instrument调试验证（这个在文章结尾会做介绍）。因此通常如果要模拟更真实全面的冷启动，在kill app后，再打开/并稍微使用几个其他app。\n 通常说的启动，也是指的冷启动；启动优化大部分也是做冷启动部分的性能优化 暂且可以把冷启动分为几个阶段：\n T1: main之前，加载App可执行文件到内存，然后执行一系列的加载\u0026amp;链接等工作，最后执行到main()函数 T2: main之后，didFinishLaunching之前，这部分开发是可以监听到的 T3: didFinishLaunching之后，启动页面出现之前，也是可以监听的  热启动 热启动的阶段和状态都是可监听的，不做过多介绍。\n应用程序的状态 1 2 3 4 5 6 7 8 9 10 11 12  启动程序 willFinishLaunchingWithOptions didFinishLaunchingWithOptions applicationDidBecomeActive 按下home键 applicationWillResignActive applicationDidEnterBackground 双击home键，再打开程序 applicationWillEnterForeground applicationDidBecomeActive   简单理解编译过程 应用程序加载过程中会依赖很多底层库，这些底层库其实就是可执行的代码的二进制，被操作系统写入到内存。 静态库 比如： .a, .lib 在链接阶段，会将汇编生成的目标与引用的库一起链接打包到可执行文件中。 动态库 比如： framework，.so, .dll，UIKIT.framework， libsystem， libdispatch，libobjc 动态库根据需要编译，动态加载，在运行时才被载入，节约资源，减小体积。 快速定位核心源码入口   main函数，断点堆栈（Debug/Debug Workflow/Always Show Disassembly 开启汇编Debug）可以看到是最早是：dyld的start:   根据已有常识，还有一个特殊方法 + load（或+ (void)initialize）方法，在此断点   初探结论：_dyld_start -\u0026gt; +load -\u0026gt; main -\u0026gt; +initialize\n  接下来就跟着dyld源码 初步搜索 _dyld_start\n   源码学习小Tips\n OC 底层是 C/C++/汇编 所以源码常见搜索技巧：XXXX(或者删除) XXXX:: ::XXXX XXXX( 主逻辑很可能在 if else 判断 ； while / do-while； for 里面 通过返回值 - 定位核心逻辑 （尤其汇编，重点关注bl） 看官方源码，多关注有注释的地方； 抓主干，跳过类似 check / if-return逻辑；跳过预编译非主架构逻辑（ios架构：arm64）   搜索__dyld_start,只看arm64下的 看不懂汇编没关系，看后面的注释，大概能明白其含义，直到出现bl跳转，再结合其注释，基本定位到核心代码：\n1 2 3  // call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, \u0026amp;startGlue) bl\t__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm mov\tx16,x0 // save entry point address in x16    搜索 dyldbootstrap::star，::start 未果，猜测C方法，搜索start( ，确定dyld - star 最终入口函数。\n 这样首先可以确认最终入口方法uintptr_t start(...)\n入口函数 uintptr_t start(\u0026hellip;) 1 2 3 4 5 6 7 8 9 10  intptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) { // rebaseDyldIfNeeded // mach_init // apple_guard_setup return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); }   核心函数 dyld::_main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  uintptr_t _main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) { // settupEnv 环境变量的相关处理 ... checkEnvironmentVariables(envp); defaultUninitializedFallbackPaths(envp); ... // load shared cache（共享缓存处理） ... // load shared cache checkSharedRegionDisable(...); mapSharedCache(); ... // 将dyld加到UUID列表 ... // add dyld itself to UUID list addDyldImageToUUIDList(); ... // ... [1]reloadAllImages: [1.1]mainExecutable ... (实例化主程序) ... // [1.2]load any inserted libraries (加载任何插入动态库) if\t( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); } ... // [1.3.1]link main executable (链接库) link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); ... // [1.3.2]link any inserted libraries // [2]run all initializers (运行所有初始化程序) initializeMainExecutable(); // [3]notify any montoring proccesses that this process is about to enter main() (通知监听dyld-main) ... notifyMonitoringDyldMain(); }   dyld核心源码流程 1. reloadAllImages 1.1 实例化主程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path) { // try mach-o loader if ( isCompatibleMachO((const uint8_t*)mh, path) ) { ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image); return (ImageLoaderMachO*)image; } ... } // create image for main executable ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext\u0026amp; context) { .... bool compressed; unsigned int segCount; // 段的数量 unsigned int libCount; // lib库的数量 ... sniffLoadCommands(mh, path, false, \u0026amp;compressed, \u0026amp;segCount, \u0026amp;libCount, context, \u0026amp;codeSigCmd, \u0026amp;encryptCmd); // instantiate concrete class based on content of load commands ... }    instantiateFromLoadedImage -\u0026gt; instantiateMainExecutable -\u0026gt; sniffLoadCommands addImage  1.2 加载任何插入动态库 在uintptr_t _main(\u0026hellip;) 函数有如下核心流程\n1 2 3 4 5  // load any inserted libraries if\t( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); }   loadInsertedDylib\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 使用动态库注入代码可以参考这个 static void loadInsertedDylib(const char* path) { ImageLoader* image = NULL; unsigned cacheIndex; try { LoadContext context; context.useSearchPaths\t= false; ... image = load(path, context, cacheIndex); } catch (const char* msg) { ... } }   这样就完成了将lib库以镜像文件的形式加载进来了，并生成对应的Image，只需要在合适的地方进行映射即可。\n1.3 链接库 在uintptr_t _main(\u0026hellip;) 函数有如下核心流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses if ( sInsertedDylibCount \u0026gt; 0 ) { for(unsigned int i=0; i \u0026lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-\u0026gt;setNeverUnloadRecursive(); } // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i \u0026lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; image-\u0026gt;registerInterposing(gLinkContext); } } ... // Bind and notify for the inserted images now interposing has been registered if ( sInsertedDylibCount \u0026gt; 0 ) { for(unsigned int i=0; i \u0026lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; image-\u0026gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); } }   1. 遍历 link images  根据loadInsertedDylib 后的 sInsertedDylibCount，遍历已经加载的动态库； 根据ImageLoaderMachO::instantiateMainExecutable -\u0026gt; sAllImages遍历执行 ImageLoader* image = sAllImages[i+1];； link image  递归操作    2.递归插入/加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  void ImageLoader::link(const LinkContext\u0026amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain\u0026amp; loaderRPaths, const char* imagePath) { ... // 递归加载 this-\u0026gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly); ... // 递归刷新依赖库的层级 this-\u0026gt;recursiveUpdateDepth(context.imageCount()); // 符号绑定 __block uint64_t t2, t3, t4, t5; { ... this-\u0026gt;recursiveRebase(context); context.notifyBatch(dyld_image_state_rebased, false); t3 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-\u0026gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); t4 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-\u0026gt;weakBind(context); t5 = mach_absolute_time(); } ... this-\u0026gt;recursiveGetDOFSections(context, dofs); context.registerDOFs(dofs); uint64_t t7 = mach_absolute_time();\t// interpose any dynamically loaded images if ( !context.linkingMainExecutable \u0026amp;\u0026amp; (fgInterposingTuples.size() != 0) ) { dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0); this-\u0026gt;recursiveApplyInterposing(context); } ... }   2. 运行所有初始化程序 - run all initializers  执行所有插入的dylib执行初始化 执行主程序初始化  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void initializeMainExecutable() { .... // run initialzers for any inserted dylibs ImageLoader::InitializerTimingList initializerTimes[allImagesCount()]; initializerTimes[0].count = 0; const size_t rootCount = sImageRoots.size(); if ( rootCount \u0026gt; 1 ) { for(size_t i=1; i \u0026lt; rootCount; ++i) { sImageRoots[i]-\u0026gt;runInitializers(gLinkContext, initializerTimes[0]); } } // run initializers for main executable and everything it brings up sMainExecutable-\u0026gt;runInitializers(gLinkContext, initializerTimes[0]); ... }   2.1 runInitializers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void ImageLoader::runInitializers(const LinkContext\u0026amp; context, InitializerTimingList\u0026amp; timingInfo) { ... processInitializers(context, thisThread, timingInfo, up); context.notifyBatch(dyld_image_state_initialized, false); ... } void ImageLoader::processInitializers(const LinkContext\u0026amp; context, mach_port_t thisThread, InitializerTimingList\u0026amp; timingInfo, ImageLoader::UninitedUpwards\u0026amp; images) { // 初始化准备 ... // Calling recursive init on all images in images list, building a new list of // uninitialized upward dependencies. // 遍历初始化 for (uintptr_t i=0; i \u0026lt; images.count; ++i) { // 递归，一个个初始化 images.images[i]-\u0026gt;recursiveInitialization(context, thisThread, images.images[i]-\u0026gt;getPath(), timingInfo, ups); } ... }   1. recursiveInitialization notifySingle，通知dyld_image_states状态的改变 doInitialization， 完成初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  void ImageLoader::recursiveInitialization(const LinkContext\u0026amp; context, mach_port_t this_thread, const char* pathToInitialize, InitializerTimingList\u0026amp; timingInfo, UninitedUpwards\u0026amp; uninitUps) { recursive_lock lock_info(this_thread); recursiveSpinLock(lock_info); if ( fState \u0026lt; dyld_image_state_dependents_initialized-1 ) { uint8_t oldState = fState; // break cycles fState = dyld_image_state_dependents_initialized-1; try { // initialize lower level libraries first .... // let objc know we are about to initialize this image .... context.notifySingle(dyld_image_state_dependents_initialized, this, \u0026amp;timingInfo); // initialize this image bool hasInitializers = this-\u0026gt;doInitialization(context); // let anyone know we finished initializing this image .... context.notifySingle(dyld_image_state_initialized, this, NULL); .... } ... } recursiveSpinUnLock(); }   2. doInitialization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  bool ImageLoaderMachO::doInitialization(const LinkContext\u0026amp; context) { .... // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); .... } void ImageLoaderMachO::doModInitFunctions(const LinkContext\u0026amp; context) { if ( fHasInitializers ) { const uint32_t cmd_count = ((macho_header*)fMachOData)-\u0026gt;ncmds; const struct load_command* const cmds = (struct load_command*)\u0026amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i \u0026lt; cmd_count; ++i) { if ( cmd-\u0026gt;cmd == LC_SEGMENT_COMMAND ) { for (const struct macho_section* sect=sectionsStart; sect \u0026lt; sectionsEnd; ++sect) { const uint8_t type = sect-\u0026gt;flags \u0026amp; SECTION_TYPE; ... Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); ... for (size_t j=0; j \u0026lt; count; ++j) { Initializer func = inits[j]; .... } .... } } cmd = (const struct load_command*)(((char*)cmd)+cmd-\u0026gt;cmdsize); } } }   3. notifySingle 这里(*sNotifyObjCInit)(image-\u0026gt;getRealPath(), image-\u0026gt;machHeader());就是获取函数指针地址，执行对应的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo) { //dyld::log(\u0026#34;notifySingle(state=%d, image=%s)\\n\u0026#34;, state, image-\u0026gt;getPath()); .... if ( state == dyld_image_state_mapped ) { .... } if ( (state == dyld_image_state_dependents_initialized) \u0026amp;\u0026amp; (sNotifyObjCInit != NULL) \u0026amp;\u0026amp; image-\u0026gt;notifyObjC() ) { .... (*sNotifyObjCInit)(image-\u0026gt;getRealPath(), image-\u0026gt;machHeader()); .... } // mach message csdlc about dynamically unloaded images if ( image-\u0026gt;addFuncNotified() \u0026amp;\u0026amp; (state == dyld_image_state_terminated) ) { .... notifyMonitoringDyld(true, 1, loadAddress, loadPath); } }   所以到此，可以看出sNotifyObjCInit是一个c函数指针地址，dyld通过获取到libobjc函数指针，可以执行到libobjc里面。 在dyld源码中全局搜索sNotifyObjCInit,可以找到sNotifyObjCInit赋值的地方发生在registerObjCNotifiers\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped) { // record functions to call sNotifyObjCMapped\t= mapped; sNotifyObjCInit\t= init; sNotifyObjCUnmapped = unmapped; ... // \u0026lt;rdar://problem/32209809\u0026gt; call \u0026#39;init\u0026#39; function on all images already init\u0026#39;ed (below libSystem) for (std::vector\u0026lt;ImageLoader*\u0026gt;::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) { ImageLoader* image = *it; if ( (image-\u0026gt;getState() == dyld_image_state_initialized) \u0026amp;\u0026amp; image-\u0026gt;notifyObjC() ) { dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-\u0026gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-\u0026gt;getRealPath(), image-\u0026gt;machHeader()); } } ... } void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped) { dyld::registerObjCNotifiers(mapped, init, unmapped); }   进一步在dyld中查找registerObjCNotifiers,_dyld_objc_notify_register，可以分析出，这个register函数是extern，并不是在dyld发起调用的。至于到底在哪里调用，后面会详细说明。\n3. 回调监听 1. 猜测流程 到此可以猜测，dyld -\u0026gt; libobjc 的方式是通过这种函数指针的方式进行通信, 应该是libobjc在某个地方进行了registerObjCNotifiers，这样dyld start后，根据上述流程，即可跳转到libobjc。这种不同库之间 register-notify的方式进行通信的完成代码调用的，明显代码在一个库里面一行行跟进代码是行不通的。所以接下来需要捋一下思路。\n2. 提出疑问 那么现在有两个疑问：\n OC怎么将自己的函数指针传给dyld的呢？ OC又是在什么时候完成注册的呢？ OC-dyld之间的相互通信是如何配合的呢？  libobjc 启动核心源码分析 直接从苹果官网下载libobjc源码。\n找到 _dyld_objc_notify_register 入口 在dyld源码分析中，能看出libobjc是通过 调用_dyld_objc_notify_register来完成注册的。在libobjc源码中搜索_dyld_objc_notify_register,发现其在_objc_init里调用，完成的向dyld注册函数。\n1 2 3 4 5 6 7  void _objc_init(void) { .... _dyld_objc_notify_register(\u0026amp;map_images, load_images, unmap_image); .... }   通过_dyld_objc_notify_register(\u0026amp;map_images, load_images, unmap_image) 可以快速解答了前面问题1（什么时候注册）和问题2（如何注册）。 并且我们也能看到dyld里面的sNotifyObjCInit即是libobjc的load_images函数，sNotifyObjCMapped是map_images函数。 现在又有新的问题产生了，虽然明确了libobjc向dyld注册函数发生在_objc_init里面，但是_objc_init到底什么时候触发的还是不知道。\nbuild \u0026amp; run libobjc 然后根据自己的Xcode和系统版本，将libobjc源码build，并run起来。这里就不做详细介绍）\n objc818-canrun for Bigsur, objc838-canrun for Monterey 在这里可以自己根据当前环境找一个源码尝试跑一个。\n  简单的思路就是在github上把源码down下来，然后直接build，那种找不到符号的报错直接先注释，找不到文件的去apple的open source搜索下，如果找到了，就添加到自己的工程下面。基本这样操作完了，就没error了，然后新建一个target, 将objc库添加到target的Dependencies 里面。如下图所示。\n 为了明确_objc_init的调用时机，简单的思路就是在_objc_init里面加一个断点，看堆栈。\n确认基础流程 dyld -\u0026gt;libsystem -\u0026gt;libdispatch -\u0026gt;libobjc -\u0026gt;_objc_init\n从打印的详细堆栈信息看，dyld_dyld_start-\u0026gt; \u0026hellip;. -\u0026gt;ImageLoaderMachO::doModInitFunction这个过程的流程正好跟前面dyld 源码分析的过程吻合上了。后面是libSystem.B.dylib libSystem_initializer(猜测这个过程应该是doModInitFunction里面调起的) -\u0026gt;libdispatch-\u0026gt;libobjc\n在dyld中的搜索image-\u0026gt;getRealPath() 基本可以确定libobjc注册的函数的调用时机。在notifyBatchPartial和notifySingle根据dyld_image_states触发不同的注册函数。\n dyld_image_state_bound 触发 libjobcmap_images dyld_image_state_initialized 触发libobjc load_images\n 验证流程 - 配合libSytem源码，libdispatch源码 在前面dyld已经分析到了doModInitFunctions里面\ndyld 初始化必须确保先完成 libSystem 初始化 回到dyld 的doModInitFunctions的部分代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  .... Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); .... Initializer func = inits[j]; // \u0026lt;rdar://problem/8543820\u0026amp;9228031\u0026gt; verify initializers are in image if ( ! this-\u0026gt;containsAddress(stripPointer((void*)func)) ) { dyld::throwf(\u0026#34;initializer function %p not in mapped image for %s\\n\u0026#34;, func, this-\u0026gt;getPath()); } if ( ! dyld::gProcessInfo-\u0026gt;libSystemInitialized ) { // \u0026lt;rdar://problem/17973316\u0026gt; libSystem initializer must run first const char* installPath = getInstallPath(); if ( (installPath == NULL) || (strcmp(installPath, LIBSYSTEM_DYLIB_PATH) != 0) ) dyld::throwf(\u0026#34;initializer in image (%s) that does not link with libSystem.dylib\\n\u0026#34;, this-\u0026gt;getPath()); } if ( context.verboseInit ) dyld::log(\u0026#34;dyld: calling initializer function %p in %s\\n\u0026#34;, func, this-\u0026gt;getPath()); bool haveLibSystemHelpersBefore = (dyld::gLibSystemHelpers != NULL); { dyld3::ScopedTimer(DBG_DYLD_TIMING_STATIC_INITIALIZER, (uint64_t)fMachOData, (uint64_t)func, 0); func(context.argc, context.argv, context.envp, context.apple, \u0026amp;context.programVars); }   可以看到dyld确实要走并确定先到libSystem的initializer\nlibSytem initializer 再到libSystem源码中搜索initializer，确定入口 libSystem_initializer,接下来就是一个个方法跟踪查看，最终可以看出流程为 libSystem_initializer-\u0026gt; libdispatch_init\nlibdispatch_init 到libdispatch源码中常规分析思路，最终流程为 libdispatch_init-\u0026gt; _os_object_init-\u0026gt; _objc_init 到这里，通过源码也验证了 上述堆栈的流程。\n启动完整流程 简化流程图 详细流程图 实际应用 main之前 - 调试 \u0026amp; 监测 1. Xcode打印pre-main的时间：开发环境Xcode DYLD_PRINT_STATICS = 1  dylid loading time:动态库加载时间，载入动态库,尽可能使用系统库,自定义库，最好不要大于6个（apple推荐） rebase（修正偏移指针 ASLR-修复内部指针） / binding time （外部符号绑定）:（fishhook） Objc set up time， 减少OC类，有统计2万个oc类增加800毫秒，swift比OC的效率更高，删除弃用的类（找工具检测） initializer time load方法 懒加载，尽量放在initialize 去调用 slowest initializer:最慢的几个库的时间 libsystem:  2. Instrument - SystemTrace / TimeProfiler 会记录启动的一些信息\n3. Xcode配置LinkMap，拿到LinkMap文件，分析 4. 其他（1，2不推荐，开拓思路）  定时抓取主线程上的方法调用堆栈（backtrace），计算一段时间里各个方法的耗时。 hook objc_msgSend 方法进行hook，掌握所有方法的执行耗时 （libffi, facebook fishhook） 在启动的相关时机插入自定义的动态库，配合技术埋点 Apple-Metrics（可自定义） 配合分析线上  ","date":"2022-03-25T00:00:00Z","permalink":"https://wangmingyou.github.io/p/ios-app-launch/","title":"iOS应用程序加载"},{"content":"objc 源码 objc818-canrun\nobjc838-canrun\n","date":"2022-02-18T00:00:00Z","permalink":"https://wangmingyou.github.io/p/open_source/","title":"源码学习"},{"content":"入口 objc_msgSend 提出疑问 方法 -\u0026gt; 消息， 如何发送的？\nsel-imp 方法编译为函数默认有两个参数 （id self， SEL _cmd）\nself: 消息接受者\n_cmd: 方法编号， 找到具体函数实现\n目录 （SEL），页码（IMP： 指向函数具体实现的指针），具体内容（函数实现 ）\n如何从SEL 找到 IMP\n汇编，断点查看 libobjc源码分析 进入汇编查找过程 objc-msg-arm64 ENTRY _objc_msgSend\nCacheLookup  CacheLookup, 有缓存列表   CacheHit，找到返回  直接从寄存器获取\nCheckMiss，没找到  正常就是用Normal进来的，所以走__objc_msgSend_uncached\nc. add 添加进去，方便下次操作\nMethodTableLookup 我们都知道OC的对象最终汇编成结构体，结构体是Class，也就是objc_class\n由此可以看到在结构体里面有： 方法列表，属性列表，协议列表\nruntime 是由 C, C++, 汇编混合提供运行时功能， 所以搜索删除一个\u0026quot;_\u0026quot;, 搜索\u0026quot;_class_lookupMethodAndLoadCache3\u0026quot;\n进入C/C++函数方法 查找过程 此时已经离开汇编过程（快速），从lookUpImpOrForward开始进入慢速查找过程\ncls： Class 类对象\ncls类对象\n实例对象\n元类对象\n继承关系实现 实际应用  NSObject 分类添加方法，防止崩溃 网络获取数据，可能int/string，int.length，不知道方法是什么，应该动态添加 遇到崩溃，提示退出页面，上报crash，动态处理  动态方法解析 TypeEcoding v@: id:self, cmd -\u0026gt; void\n消息转发 aspect，消息转发的具体应用\n源码跑功能   消息发送的流程图 总结  方法的本质是发送消息，发送消息的几个流程    快速查找（objc_msgSend）~ cache_t 缓存消息 慢速查找～ 递归自己｜父类～ lookupImpOrForWard 查不到消息：动态⽅法解析~ resolveInstanceMethod 消息快速转发~ forwardingTargetForSelector 消息慢速转发~ methodSignatureForSelector \u0026amp; forwardInvocation   sel 是方法编号，在read_images期间就编译进内存 imp是函数实现的指针，找imp就是找函数   sel 可以理解为书本的目录标题，imp就是书本的页码。查找具体的函数，就是看这本书里面具体的内容，通过想看的标题找到对应的页骂最后翻到具体的内容，即是 sel - 指针(imp) - 具体实现\n ","date":"2020-01-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/objc_msgsend/","title":"消息发送源码学习"},{"content":"直接看一段代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @interface Person : NSObject @end @implementation Person @end @interface Worker : Person @end @implementation Worker - (instancetype)init{ self = [super init]; if (self) { NSLog(@\u0026#34;🦁️ [self class] %@\u0026#34;,NSStringFromClass([self class])); NSLog(@\u0026#34;🦁️ [super class] %@\u0026#34;,NSStringFromClass([super class])); } return self; } @end @implementation TestSuperClass // 分析 [self class] 与 [super class] 的区别 - (void) test { Worker *worker = [[Worker alloc] init]; } @end   打印结果： 1 2  2022-04-09 19:08:09.612737+0800 Object-CDemo[68945:1164926] 🦁️ [self class] Worker 2022-04-09 19:08:09.612854+0800 Object-CDemo[68945:1164926] 🦁️ [super class] Worker    相信一个打印大家都很好理解，第二个就不好理解了，那么现在主要来分析下 super class\n  在objc 源码中 找到class 的源码实现\n 1 2 3 4 5 6 7  - (Class)class { /* 1. 所有的函数，都有两个默认的隐藏参数：(id self , sel _cmd), 这里的用的self就是第一个隐藏参数，就是消息的接受体 2. 现在的关键问题是，隐藏参数self 到底是谁，也就是消息的接受者是谁 */ return object_getClass(self); }    这里显而易见，所以第一个[self class]的self是worker就显而易见了。那么第二个为什么也是worker呢？\n 分析的常见思路 方法1: clang 看到底底层编译成什么样的源码 方法2: objc源码 run起来，直接断点分析分析 方法3: 断点汇编 + 源码配合 分析 方法4: NSObject MethodSwizzling class 方法  前两种方法，我觉得都有点麻烦，方法4，MethodSwizzling也只是验证打印结果，对我们分析本质，帮助可能不大，所以我直接选择方法3，快捷还可以分析底层原因。\n 断点汇编分析 首先选择断点的汇编模式      这里显而易见 [super class] 最终走的是objc_msgSendSuper2消息发送，再结合源码。\n 1 2 3  objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...) #endif   // 通过objc源码里面简化 objc_super\n1 2 3 4 5  struct objc_super { __unsafe_unretained _Nonnull id receiver; //消息接收者 __unsafe_unretained _Nonnull Class super_class; };    也就是NSLog(@\u0026quot;🦁️ [super class] %@\u0026quot;,NSStringFromClass([super class])) 等同于下面的一段代码\n 1 2 3 4 5 6  // [super class] 等同于下面一段代码 struct objc_super test_super = { self, // 研究对象是在worker里面 class_getSuperclass([self class]), }; NSLog(@\u0026#34;%@\u0026#34;,NSStringFromClass(objc_msgSendSuper2(\u0026amp;test_super,@selector(class))));    转化后很好理解了，其实就是给self（worker）发送消息，调用class方法。这样就能理解打印结果了。\n 那么 [super class] 与 [self class] 有什么区别呢  虽然现在理解了两者结果一样，那么[super class] 有什么特殊的呢？也就是objc_super 里面的 class_getSuperclass([self class]), 存在的意义是什么呢？ 其实本质区别就是objc_msgSendSuper 与objc_msgSend 有什么区别?\n objc_msgSend 流程 objc_msgSend具体流程 可以看到这个objc_msgSend慢速流程回去遍历父类，比较慢，objc_msgSendSuper就可以跳过很多遍历，变得更快了。\n结论  [self class] 就是发送消息objc_msgSend，消息接受者是 self ⽅法编号：class [super class] 本质就是objc_msgSendSuper, 消息的接受者还是 self ⽅法编号：class 逻辑教育 只是objc_msgSendSuper 会更快 直接跳过 self 的查找\n ","date":"2019-03-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/super-class-study/","title":"分析 在OC中 [self class] 与 [super class] 的区别"}]