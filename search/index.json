[{"content":"iOSåº”ç”¨ç¨‹åºåŠ è½½ å‰è¨€ è¿™ç¯‡æ–‡ç« çš„æ ¸å¿ƒç›®çš„æ˜¯è·Ÿç€è‹¹æœæºç ï¼Œæ·±åº¦å­¦ä¹ å¹¶ç†è§£iOS APPå¯åŠ¨è¿‡ç¨‹ã€‚\nåŸºç¡€æ¦‚å¿µ å†·å¯åŠ¨  æ³¨æ„ï¼šåœ¨æ—¥å¸¸å¼€å‘æˆ–æµ‹è¯•çš„æ—¶å€™ä¸ºäº†ï¼Œè§¦å‘å†·å¯åŠ¨çŠ¶æ€ï¼Œä¼šæ‰‹åŠ¨kill appï¼Œç„¶åç‚¹å‡»å¯åŠ¨ã€‚è¿™ç§æƒ…å†µä¸‹çš„å†·å¯åŠ¨å¯èƒ½ä¼šä¸ä¸Šè¿°å†·å¯åŠ¨è¿‡ç¨‹çš„æ­¥éª¤ç¨å¾®å°‘äº›ï¼Œå¯ä»¥é…åˆInstrumentè°ƒè¯•éªŒè¯ï¼ˆè¿™ä¸ªåœ¨æ–‡ç« ç»“å°¾ä¼šåšä»‹ç»ï¼‰ã€‚å› æ­¤é€šå¸¸å¦‚æœè¦æ¨¡æ‹Ÿæ›´çœŸå®å…¨é¢çš„å†·å¯åŠ¨ï¼Œåœ¨kill appåï¼Œå†æ‰“å¼€/å¹¶ç¨å¾®ä½¿ç”¨å‡ ä¸ªå…¶ä»–appã€‚\n é€šå¸¸è¯´çš„å¯åŠ¨ï¼Œä¹Ÿæ˜¯æŒ‡çš„å†·å¯åŠ¨ï¼›å¯åŠ¨ä¼˜åŒ–å¤§éƒ¨åˆ†ä¹Ÿæ˜¯åšå†·å¯åŠ¨éƒ¨åˆ†çš„æ€§èƒ½ä¼˜åŒ– æš‚ä¸”å¯ä»¥æŠŠå†·å¯åŠ¨åˆ†ä¸ºå‡ ä¸ªé˜¶æ®µï¼š\n T1: mainä¹‹å‰ï¼ŒåŠ è½½Appå¯æ‰§è¡Œæ–‡ä»¶åˆ°å†…å­˜ï¼Œç„¶åæ‰§è¡Œä¸€ç³»åˆ—çš„åŠ è½½\u0026amp;é“¾æ¥ç­‰å·¥ä½œï¼Œæœ€åæ‰§è¡Œåˆ°main()å‡½æ•° T2: mainä¹‹åï¼ŒdidFinishLaunchingä¹‹å‰ï¼Œè¿™éƒ¨åˆ†å¼€å‘æ˜¯å¯ä»¥ç›‘å¬åˆ°çš„ T3: didFinishLaunchingä¹‹åï¼Œå¯åŠ¨é¡µé¢å‡ºç°ä¹‹å‰ï¼Œä¹Ÿæ˜¯å¯ä»¥ç›‘å¬çš„  çƒ­å¯åŠ¨ çƒ­å¯åŠ¨çš„é˜¶æ®µå’ŒçŠ¶æ€éƒ½æ˜¯å¯ç›‘å¬çš„ï¼Œä¸åšè¿‡å¤šä»‹ç»ã€‚\nåº”ç”¨ç¨‹åºçš„çŠ¶æ€ 1 2 3 4 5 6 7 8 9 10 11 12  å¯åŠ¨ç¨‹åº willFinishLaunchingWithOptions didFinishLaunchingWithOptions applicationDidBecomeActive æŒ‰ä¸‹homeé”® applicationWillResignActive applicationDidEnterBackground åŒå‡»homeé”®ï¼Œå†æ‰“å¼€ç¨‹åº applicationWillEnterForeground applicationDidBecomeActive   ç®€å•ç†è§£ç¼–è¯‘è¿‡ç¨‹ åº”ç”¨ç¨‹åºåŠ è½½è¿‡ç¨‹ä¸­ä¼šä¾èµ–å¾ˆå¤šåº•å±‚åº“ï¼Œè¿™äº›åº•å±‚åº“å…¶å®å°±æ˜¯å¯æ‰§è¡Œçš„ä»£ç çš„äºŒè¿›åˆ¶ï¼Œè¢«æ“ä½œç³»ç»Ÿå†™å…¥åˆ°å†…å­˜ã€‚ é™æ€åº“ æ¯”å¦‚ï¼š .a, .lib åœ¨é“¾æ¥é˜¶æ®µï¼Œä¼šå°†æ±‡ç¼–ç”Ÿæˆçš„ç›®æ ‡ä¸å¼•ç”¨çš„åº“ä¸€èµ·é“¾æ¥æ‰“åŒ…åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ã€‚ åŠ¨æ€åº“ æ¯”å¦‚ï¼š frameworkï¼Œ.so, .dllï¼ŒUIKIT.frameworkï¼Œ libsystemï¼Œ libdispatchï¼Œlibobjc åŠ¨æ€åº“æ ¹æ®éœ€è¦ç¼–è¯‘ï¼ŒåŠ¨æ€åŠ è½½ï¼Œåœ¨è¿è¡Œæ—¶æ‰è¢«è½½å…¥ï¼ŒèŠ‚çº¦èµ„æºï¼Œå‡å°ä½“ç§¯ã€‚ å¿«é€Ÿå®šä½æ ¸å¿ƒæºç å…¥å£   mainå‡½æ•°ï¼Œæ–­ç‚¹å †æ ˆï¼ˆDebug/Debug Workflow/Always Show Disassembly å¼€å¯æ±‡ç¼–Debugï¼‰å¯ä»¥çœ‹åˆ°æ˜¯æœ€æ—©æ˜¯ï¼šdyldçš„start:   æ ¹æ®å·²æœ‰å¸¸è¯†ï¼Œè¿˜æœ‰ä¸€ä¸ªç‰¹æ®Šæ–¹æ³• + loadï¼ˆæˆ–+ (void)initializeï¼‰æ–¹æ³•ï¼Œåœ¨æ­¤æ–­ç‚¹   åˆæ¢ç»“è®ºï¼š_dyld_start -\u0026gt; +load -\u0026gt; main -\u0026gt; +initialize\n  æ¥ä¸‹æ¥å°±è·Ÿç€dyldæºç  åˆæ­¥æœç´¢ _dyld_start\n   æºç å­¦ä¹ å°Tips\n OC åº•å±‚æ˜¯ C/C++/æ±‡ç¼– æ‰€ä»¥æºç å¸¸è§æœç´¢æŠ€å·§ï¼šXXXX(æˆ–è€…åˆ é™¤) XXXX:: ::XXXX XXXX( ä¸»é€»è¾‘å¾ˆå¯èƒ½åœ¨ if else åˆ¤æ–­ ï¼› while / do-whileï¼› for é‡Œé¢ é€šè¿‡è¿”å›å€¼ - å®šä½æ ¸å¿ƒé€»è¾‘ ï¼ˆå°¤å…¶æ±‡ç¼–ï¼Œé‡ç‚¹å…³æ³¨blï¼‰ çœ‹å®˜æ–¹æºç ï¼Œå¤šå…³æ³¨æœ‰æ³¨é‡Šçš„åœ°æ–¹ï¼› æŠ“ä¸»å¹²ï¼Œè·³è¿‡ç±»ä¼¼ check / if-returné€»è¾‘ï¼›è·³è¿‡é¢„ç¼–è¯‘éä¸»æ¶æ„é€»è¾‘ï¼ˆiosæ¶æ„ï¼šarm64ï¼‰   æœç´¢__dyld_start,åªçœ‹arm64ä¸‹çš„ çœ‹ä¸æ‡‚æ±‡ç¼–æ²¡å…³ç³»ï¼Œçœ‹åé¢çš„æ³¨é‡Šï¼Œå¤§æ¦‚èƒ½æ˜ç™½å…¶å«ä¹‰ï¼Œç›´åˆ°å‡ºç°blè·³è½¬ï¼Œå†ç»“åˆå…¶æ³¨é‡Šï¼ŒåŸºæœ¬å®šä½åˆ°æ ¸å¿ƒä»£ç ï¼š\n1 2 3  // call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, \u0026amp;startGlue) bl\t__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm mov\tx16,x0 // save entry point address in x16    æœç´¢ dyldbootstrap::starï¼Œ::start æœªæœï¼ŒçŒœæµ‹Cæ–¹æ³•ï¼Œæœç´¢start( ï¼Œç¡®å®šdyld - star æœ€ç»ˆå…¥å£å‡½æ•°ã€‚\n è¿™æ ·é¦–å…ˆå¯ä»¥ç¡®è®¤æœ€ç»ˆå…¥å£æ–¹æ³•uintptr_t start(...)\nå…¥å£å‡½æ•° uintptr_t start(\u0026hellip;) 1 2 3 4 5 6 7 8 9 10  intptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) { // rebaseDyldIfNeeded // mach_init // apple_guard_setup return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); }   æ ¸å¿ƒå‡½æ•° dyld::_main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  uintptr_t _main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) { // settupEnv ç¯å¢ƒå˜é‡çš„ç›¸å…³å¤„ç† ... checkEnvironmentVariables(envp); defaultUninitializedFallbackPaths(envp); ... // load shared cacheï¼ˆå…±äº«ç¼“å­˜å¤„ç†ï¼‰ ... // load shared cache checkSharedRegionDisable(...); mapSharedCache(); ... // å°†dyldåŠ åˆ°UUIDåˆ—è¡¨ ... // add dyld itself to UUID list addDyldImageToUUIDList(); ... // ... [1]reloadAllImages: [1.1]mainExecutable ... (å®ä¾‹åŒ–ä¸»ç¨‹åº) ... // [1.2]load any inserted libraries (åŠ è½½ä»»ä½•æ’å…¥åŠ¨æ€åº“) if\t( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); } ... // [1.3.1]link main executable (é“¾æ¥åº“) link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); ... // [1.3.2]link any inserted libraries // [2]run all initializers (è¿è¡Œæ‰€æœ‰åˆå§‹åŒ–ç¨‹åº) initializeMainExecutable(); // [3]notify any montoring proccesses that this process is about to enter main() (é€šçŸ¥ç›‘å¬dyld-main) ... notifyMonitoringDyldMain(); }   dyldæ ¸å¿ƒæºç æµç¨‹ 1. reloadAllImages 1.1 å®ä¾‹åŒ–ä¸»ç¨‹åº 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path) { // try mach-o loader if ( isCompatibleMachO((const uint8_t*)mh, path) ) { ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image); return (ImageLoaderMachO*)image; } ... } // create image for main executable ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext\u0026amp; context) { .... bool compressed; unsigned int segCount; // æ®µçš„æ•°é‡ unsigned int libCount; // libåº“çš„æ•°é‡ ... sniffLoadCommands(mh, path, false, \u0026amp;compressed, \u0026amp;segCount, \u0026amp;libCount, context, \u0026amp;codeSigCmd, \u0026amp;encryptCmd); // instantiate concrete class based on content of load commands ... }    instantiateFromLoadedImage -\u0026gt; instantiateMainExecutable -\u0026gt; sniffLoadCommands addImage  1.2 åŠ è½½ä»»ä½•æ’å…¥åŠ¨æ€åº“ åœ¨uintptr_t _main(\u0026hellip;) å‡½æ•°æœ‰å¦‚ä¸‹æ ¸å¿ƒæµç¨‹\n1 2 3 4 5  // load any inserted libraries if\t( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); }   loadInsertedDylib\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // ä½¿ç”¨åŠ¨æ€åº“æ³¨å…¥ä»£ç å¯ä»¥å‚è€ƒè¿™ä¸ª static void loadInsertedDylib(const char* path) { ImageLoader* image = NULL; unsigned cacheIndex; try { LoadContext context; context.useSearchPaths\t= false; ... image = load(path, context, cacheIndex); } catch (const char* msg) { ... } }   è¿™æ ·å°±å®Œæˆäº†å°†libåº“ä»¥é•œåƒæ–‡ä»¶çš„å½¢å¼åŠ è½½è¿›æ¥äº†ï¼Œå¹¶ç”Ÿæˆå¯¹åº”çš„Imageï¼Œåªéœ€è¦åœ¨åˆé€‚çš„åœ°æ–¹è¿›è¡Œæ˜ å°„å³å¯ã€‚\n1.3 é“¾æ¥åº“ åœ¨uintptr_t _main(\u0026hellip;) å‡½æ•°æœ‰å¦‚ä¸‹æ ¸å¿ƒæµç¨‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses if ( sInsertedDylibCount \u0026gt; 0 ) { for(unsigned int i=0; i \u0026lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-\u0026gt;setNeverUnloadRecursive(); } // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i \u0026lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; image-\u0026gt;registerInterposing(gLinkContext); } } ... // Bind and notify for the inserted images now interposing has been registered if ( sInsertedDylibCount \u0026gt; 0 ) { for(unsigned int i=0; i \u0026lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; image-\u0026gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); } }   1. éå† link images  æ ¹æ®loadInsertedDylib åçš„ sInsertedDylibCountï¼Œéå†å·²ç»åŠ è½½çš„åŠ¨æ€åº“ï¼› æ ¹æ®ImageLoaderMachO::instantiateMainExecutable -\u0026gt; sAllImageséå†æ‰§è¡Œ ImageLoader* image = sAllImages[i+1];ï¼› link image  é€’å½’æ“ä½œ    2.é€’å½’æ’å…¥/åŠ è½½ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  void ImageLoader::link(const LinkContext\u0026amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain\u0026amp; loaderRPaths, const char* imagePath) { ... // é€’å½’åŠ è½½ this-\u0026gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly); ... // é€’å½’åˆ·æ–°ä¾èµ–åº“çš„å±‚çº§ this-\u0026gt;recursiveUpdateDepth(context.imageCount()); // ç¬¦å·ç»‘å®š __block uint64_t t2, t3, t4, t5; { ... this-\u0026gt;recursiveRebase(context); context.notifyBatch(dyld_image_state_rebased, false); t3 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-\u0026gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); t4 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-\u0026gt;weakBind(context); t5 = mach_absolute_time(); } ... this-\u0026gt;recursiveGetDOFSections(context, dofs); context.registerDOFs(dofs); uint64_t t7 = mach_absolute_time();\t// interpose any dynamically loaded images if ( !context.linkingMainExecutable \u0026amp;\u0026amp; (fgInterposingTuples.size() != 0) ) { dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0); this-\u0026gt;recursiveApplyInterposing(context); } ... }   2. è¿è¡Œæ‰€æœ‰åˆå§‹åŒ–ç¨‹åº - run all initializers  æ‰§è¡Œæ‰€æœ‰æ’å…¥çš„dylibæ‰§è¡Œåˆå§‹åŒ– æ‰§è¡Œä¸»ç¨‹åºåˆå§‹åŒ–  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void initializeMainExecutable() { .... // run initialzers for any inserted dylibs ImageLoader::InitializerTimingList initializerTimes[allImagesCount()]; initializerTimes[0].count = 0; const size_t rootCount = sImageRoots.size(); if ( rootCount \u0026gt; 1 ) { for(size_t i=1; i \u0026lt; rootCount; ++i) { sImageRoots[i]-\u0026gt;runInitializers(gLinkContext, initializerTimes[0]); } } // run initializers for main executable and everything it brings up sMainExecutable-\u0026gt;runInitializers(gLinkContext, initializerTimes[0]); ... }   2.1 runInitializers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void ImageLoader::runInitializers(const LinkContext\u0026amp; context, InitializerTimingList\u0026amp; timingInfo) { ... processInitializers(context, thisThread, timingInfo, up); context.notifyBatch(dyld_image_state_initialized, false); ... } void ImageLoader::processInitializers(const LinkContext\u0026amp; context, mach_port_t thisThread, InitializerTimingList\u0026amp; timingInfo, ImageLoader::UninitedUpwards\u0026amp; images) { // åˆå§‹åŒ–å‡†å¤‡ ... // Calling recursive init on all images in images list, building a new list of // uninitialized upward dependencies. // éå†åˆå§‹åŒ– for (uintptr_t i=0; i \u0026lt; images.count; ++i) { // é€’å½’ï¼Œä¸€ä¸ªä¸ªåˆå§‹åŒ– images.images[i]-\u0026gt;recursiveInitialization(context, thisThread, images.images[i]-\u0026gt;getPath(), timingInfo, ups); } ... }   1. recursiveInitialization notifySingleï¼Œé€šçŸ¥dyld_image_statesçŠ¶æ€çš„æ”¹å˜ doInitializationï¼Œ å®Œæˆåˆå§‹åŒ–\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  void ImageLoader::recursiveInitialization(const LinkContext\u0026amp; context, mach_port_t this_thread, const char* pathToInitialize, InitializerTimingList\u0026amp; timingInfo, UninitedUpwards\u0026amp; uninitUps) { recursive_lock lock_info(this_thread); recursiveSpinLock(lock_info); if ( fState \u0026lt; dyld_image_state_dependents_initialized-1 ) { uint8_t oldState = fState; // break cycles fState = dyld_image_state_dependents_initialized-1; try { // initialize lower level libraries first .... // let objc know we are about to initialize this image .... context.notifySingle(dyld_image_state_dependents_initialized, this, \u0026amp;timingInfo); // initialize this image bool hasInitializers = this-\u0026gt;doInitialization(context); // let anyone know we finished initializing this image .... context.notifySingle(dyld_image_state_initialized, this, NULL); .... } ... } recursiveSpinUnLock(); }   2. doInitialization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  bool ImageLoaderMachO::doInitialization(const LinkContext\u0026amp; context) { .... // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); .... } void ImageLoaderMachO::doModInitFunctions(const LinkContext\u0026amp; context) { if ( fHasInitializers ) { const uint32_t cmd_count = ((macho_header*)fMachOData)-\u0026gt;ncmds; const struct load_command* const cmds = (struct load_command*)\u0026amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i \u0026lt; cmd_count; ++i) { if ( cmd-\u0026gt;cmd == LC_SEGMENT_COMMAND ) { for (const struct macho_section* sect=sectionsStart; sect \u0026lt; sectionsEnd; ++sect) { const uint8_t type = sect-\u0026gt;flags \u0026amp; SECTION_TYPE; ... Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); ... for (size_t j=0; j \u0026lt; count; ++j) { Initializer func = inits[j]; .... } .... } } cmd = (const struct load_command*)(((char*)cmd)+cmd-\u0026gt;cmdsize); } } }   3. notifySingle è¿™é‡Œ(*sNotifyObjCInit)(image-\u0026gt;getRealPath(), image-\u0026gt;machHeader());å°±æ˜¯è·å–å‡½æ•°æŒ‡é’ˆåœ°å€ï¼Œæ‰§è¡Œå¯¹åº”çš„å‡½æ•°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo) { //dyld::log(\u0026#34;notifySingle(state=%d, image=%s)\\n\u0026#34;, state, image-\u0026gt;getPath()); .... if ( state == dyld_image_state_mapped ) { .... } if ( (state == dyld_image_state_dependents_initialized) \u0026amp;\u0026amp; (sNotifyObjCInit != NULL) \u0026amp;\u0026amp; image-\u0026gt;notifyObjC() ) { .... (*sNotifyObjCInit)(image-\u0026gt;getRealPath(), image-\u0026gt;machHeader()); .... } // mach message csdlc about dynamically unloaded images if ( image-\u0026gt;addFuncNotified() \u0026amp;\u0026amp; (state == dyld_image_state_terminated) ) { .... notifyMonitoringDyld(true, 1, loadAddress, loadPath); } }   æ‰€ä»¥åˆ°æ­¤ï¼Œå¯ä»¥çœ‹å‡ºsNotifyObjCInitæ˜¯ä¸€ä¸ªcå‡½æ•°æŒ‡é’ˆåœ°å€ï¼Œdyldé€šè¿‡è·å–åˆ°libobjcå‡½æ•°æŒ‡é’ˆï¼Œå¯ä»¥æ‰§è¡Œåˆ°libobjcé‡Œé¢ã€‚ åœ¨dyldæºç ä¸­å…¨å±€æœç´¢sNotifyObjCInit,å¯ä»¥æ‰¾åˆ°sNotifyObjCInitèµ‹å€¼çš„åœ°æ–¹å‘ç”Ÿåœ¨registerObjCNotifiers\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped) { // record functions to call sNotifyObjCMapped\t= mapped; sNotifyObjCInit\t= init; sNotifyObjCUnmapped = unmapped; ... // \u0026lt;rdar://problem/32209809\u0026gt; call \u0026#39;init\u0026#39; function on all images already init\u0026#39;ed (below libSystem) for (std::vector\u0026lt;ImageLoader*\u0026gt;::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) { ImageLoader* image = *it; if ( (image-\u0026gt;getState() == dyld_image_state_initialized) \u0026amp;\u0026amp; image-\u0026gt;notifyObjC() ) { dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-\u0026gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-\u0026gt;getRealPath(), image-\u0026gt;machHeader()); } } ... } void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped) { dyld::registerObjCNotifiers(mapped, init, unmapped); }   è¿›ä¸€æ­¥åœ¨dyldä¸­æŸ¥æ‰¾registerObjCNotifiers,_dyld_objc_notify_registerï¼Œå¯ä»¥åˆ†æå‡ºï¼Œè¿™ä¸ªregisterå‡½æ•°æ˜¯externï¼Œå¹¶ä¸æ˜¯åœ¨dyldå‘èµ·è°ƒç”¨çš„ã€‚è‡³äºåˆ°åº•åœ¨å“ªé‡Œè°ƒç”¨ï¼Œåé¢ä¼šè¯¦ç»†è¯´æ˜ã€‚\n3. å›è°ƒç›‘å¬ 1. çŒœæµ‹æµç¨‹ åˆ°æ­¤å¯ä»¥çŒœæµ‹ï¼Œdyld -\u0026gt; libobjc çš„æ–¹å¼æ˜¯é€šè¿‡è¿™ç§å‡½æ•°æŒ‡é’ˆçš„æ–¹å¼è¿›è¡Œé€šä¿¡, åº”è¯¥æ˜¯libobjcåœ¨æŸä¸ªåœ°æ–¹è¿›è¡Œäº†registerObjCNotifiersï¼Œè¿™æ ·dyld startåï¼Œæ ¹æ®ä¸Šè¿°æµç¨‹ï¼Œå³å¯è·³è½¬åˆ°libobjcã€‚è¿™ç§ä¸åŒåº“ä¹‹é—´ register-notifyçš„æ–¹å¼è¿›è¡Œé€šä¿¡çš„å®Œæˆä»£ç è°ƒç”¨çš„ï¼Œæ˜æ˜¾ä»£ç åœ¨ä¸€ä¸ªåº“é‡Œé¢ä¸€è¡Œè¡Œè·Ÿè¿›ä»£ç æ˜¯è¡Œä¸é€šçš„ã€‚æ‰€ä»¥æ¥ä¸‹æ¥éœ€è¦æ‹ä¸€ä¸‹æ€è·¯ã€‚\n2. æå‡ºç–‘é—® é‚£ä¹ˆç°åœ¨æœ‰ä¸¤ä¸ªç–‘é—®ï¼š\n OCæ€ä¹ˆå°†è‡ªå·±çš„å‡½æ•°æŒ‡é’ˆä¼ ç»™dyldçš„å‘¢ï¼Ÿ OCåˆæ˜¯åœ¨ä»€ä¹ˆæ—¶å€™å®Œæˆæ³¨å†Œçš„å‘¢ï¼Ÿ OC-dyldä¹‹é—´çš„ç›¸äº’é€šä¿¡æ˜¯å¦‚ä½•é…åˆçš„å‘¢ï¼Ÿ  libobjc å¯åŠ¨æ ¸å¿ƒæºç åˆ†æ ç›´æ¥ä»è‹¹æœå®˜ç½‘ä¸‹è½½libobjcæºç ã€‚\næ‰¾åˆ° _dyld_objc_notify_register å…¥å£ åœ¨dyldæºç åˆ†æä¸­ï¼Œèƒ½çœ‹å‡ºlibobjcæ˜¯é€šè¿‡ è°ƒç”¨_dyld_objc_notify_registeræ¥å®Œæˆæ³¨å†Œçš„ã€‚åœ¨libobjcæºç ä¸­æœç´¢_dyld_objc_notify_register,å‘ç°å…¶åœ¨_objc_inité‡Œè°ƒç”¨ï¼Œå®Œæˆçš„å‘dyldæ³¨å†Œå‡½æ•°ã€‚\n1 2 3 4 5 6 7  void _objc_init(void) { .... _dyld_objc_notify_register(\u0026amp;map_images, load_images, unmap_image); .... }   é€šè¿‡_dyld_objc_notify_register(\u0026amp;map_images, load_images, unmap_image) å¯ä»¥å¿«é€Ÿè§£ç­”äº†å‰é¢é—®é¢˜1ï¼ˆä»€ä¹ˆæ—¶å€™æ³¨å†Œï¼‰å’Œé—®é¢˜2ï¼ˆå¦‚ä½•æ³¨å†Œï¼‰ã€‚ å¹¶ä¸”æˆ‘ä»¬ä¹Ÿèƒ½çœ‹åˆ°dyldé‡Œé¢çš„sNotifyObjCInitå³æ˜¯libobjcçš„load_imageså‡½æ•°ï¼ŒsNotifyObjCMappedæ˜¯map_imageså‡½æ•°ã€‚ ç°åœ¨åˆæœ‰æ–°çš„é—®é¢˜äº§ç”Ÿäº†ï¼Œè™½ç„¶æ˜ç¡®äº†libobjcå‘dyldæ³¨å†Œå‡½æ•°å‘ç”Ÿåœ¨_objc_inité‡Œé¢ï¼Œä½†æ˜¯_objc_initåˆ°åº•ä»€ä¹ˆæ—¶å€™è§¦å‘çš„è¿˜æ˜¯ä¸çŸ¥é“ã€‚\nbuild \u0026amp; run libobjc ç„¶åæ ¹æ®è‡ªå·±çš„Xcodeå’Œç³»ç»Ÿç‰ˆæœ¬ï¼Œå°†libobjcæºç buildï¼Œå¹¶runèµ·æ¥ã€‚è¿™é‡Œå°±ä¸åšè¯¦ç»†ä»‹ç»ï¼‰\n objc818-canrun for Bigsur, objc838-canrun for Monterey åœ¨è¿™é‡Œå¯ä»¥è‡ªå·±æ ¹æ®å½“å‰ç¯å¢ƒæ‰¾ä¸€ä¸ªæºç å°è¯•è·‘ä¸€ä¸ªã€‚\n  ç®€å•çš„æ€è·¯å°±æ˜¯åœ¨githubä¸ŠæŠŠæºç downä¸‹æ¥ï¼Œç„¶åç›´æ¥buildï¼Œé‚£ç§æ‰¾ä¸åˆ°ç¬¦å·çš„æŠ¥é”™ç›´æ¥å…ˆæ³¨é‡Šï¼Œæ‰¾ä¸åˆ°æ–‡ä»¶çš„å»appleçš„open sourceæœç´¢ä¸‹ï¼Œå¦‚æœæ‰¾åˆ°äº†ï¼Œå°±æ·»åŠ åˆ°è‡ªå·±çš„å·¥ç¨‹ä¸‹é¢ã€‚åŸºæœ¬è¿™æ ·æ“ä½œå®Œäº†ï¼Œå°±æ²¡erroräº†ï¼Œç„¶åæ–°å»ºä¸€ä¸ªtarget, å°†objcåº“æ·»åŠ åˆ°targetçš„Dependencies é‡Œé¢ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚\n ä¸ºäº†æ˜ç¡®_objc_initçš„è°ƒç”¨æ—¶æœºï¼Œç®€å•çš„æ€è·¯å°±æ˜¯åœ¨_objc_inité‡Œé¢åŠ ä¸€ä¸ªæ–­ç‚¹ï¼Œçœ‹å †æ ˆã€‚\nç¡®è®¤åŸºç¡€æµç¨‹ dyld -\u0026gt;libsystem -\u0026gt;libdispatch -\u0026gt;libobjc -\u0026gt;_objc_init\nä»æ‰“å°çš„è¯¦ç»†å †æ ˆä¿¡æ¯çœ‹ï¼Œdyld_dyld_start-\u0026gt; \u0026hellip;. -\u0026gt;ImageLoaderMachO::doModInitFunctionè¿™ä¸ªè¿‡ç¨‹çš„æµç¨‹æ­£å¥½è·Ÿå‰é¢dyld æºç åˆ†æçš„è¿‡ç¨‹å»åˆä¸Šäº†ã€‚åé¢æ˜¯libSystem.B.dylib libSystem_initializer(çŒœæµ‹è¿™ä¸ªè¿‡ç¨‹åº”è¯¥æ˜¯doModInitFunctioné‡Œé¢è°ƒèµ·çš„) -\u0026gt;libdispatch-\u0026gt;libobjc\nåœ¨dyldä¸­çš„æœç´¢image-\u0026gt;getRealPath() åŸºæœ¬å¯ä»¥ç¡®å®šlibobjcæ³¨å†Œçš„å‡½æ•°çš„è°ƒç”¨æ—¶æœºã€‚åœ¨notifyBatchPartialå’ŒnotifySingleæ ¹æ®dyld_image_statesè§¦å‘ä¸åŒçš„æ³¨å†Œå‡½æ•°ã€‚\n dyld_image_state_bound è§¦å‘ libjobcmap_images dyld_image_state_initialized è§¦å‘libobjc load_images\n éªŒè¯æµç¨‹ - é…åˆlibSytemæºç ï¼Œlibdispatchæºç  åœ¨å‰é¢dyldå·²ç»åˆ†æåˆ°äº†doModInitFunctionsé‡Œé¢\ndyld åˆå§‹åŒ–å¿…é¡»ç¡®ä¿å…ˆå®Œæˆ libSystem åˆå§‹åŒ– å›åˆ°dyld çš„doModInitFunctionsçš„éƒ¨åˆ†ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  .... Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); .... Initializer func = inits[j]; // \u0026lt;rdar://problem/8543820\u0026amp;9228031\u0026gt; verify initializers are in image if ( ! this-\u0026gt;containsAddress(stripPointer((void*)func)) ) { dyld::throwf(\u0026#34;initializer function %p not in mapped image for %s\\n\u0026#34;, func, this-\u0026gt;getPath()); } if ( ! dyld::gProcessInfo-\u0026gt;libSystemInitialized ) { // \u0026lt;rdar://problem/17973316\u0026gt; libSystem initializer must run first const char* installPath = getInstallPath(); if ( (installPath == NULL) || (strcmp(installPath, LIBSYSTEM_DYLIB_PATH) != 0) ) dyld::throwf(\u0026#34;initializer in image (%s) that does not link with libSystem.dylib\\n\u0026#34;, this-\u0026gt;getPath()); } if ( context.verboseInit ) dyld::log(\u0026#34;dyld: calling initializer function %p in %s\\n\u0026#34;, func, this-\u0026gt;getPath()); bool haveLibSystemHelpersBefore = (dyld::gLibSystemHelpers != NULL); { dyld3::ScopedTimer(DBG_DYLD_TIMING_STATIC_INITIALIZER, (uint64_t)fMachOData, (uint64_t)func, 0); func(context.argc, context.argv, context.envp, context.apple, \u0026amp;context.programVars); }   å¯ä»¥çœ‹åˆ°dyldç¡®å®è¦èµ°å¹¶ç¡®å®šå…ˆåˆ°libSystemçš„initializer\nlibSytem initializer å†åˆ°libSystemæºç ä¸­æœç´¢initializerï¼Œç¡®å®šå…¥å£ libSystem_initializer,æ¥ä¸‹æ¥å°±æ˜¯ä¸€ä¸ªä¸ªæ–¹æ³•è·Ÿè¸ªæŸ¥çœ‹ï¼Œæœ€ç»ˆå¯ä»¥çœ‹å‡ºæµç¨‹ä¸º libSystem_initializer-\u0026gt; libdispatch_init\nlibdispatch_init åˆ°libdispatchæºç ä¸­å¸¸è§„åˆ†ææ€è·¯ï¼Œæœ€ç»ˆæµç¨‹ä¸º libdispatch_init-\u0026gt; _os_object_init-\u0026gt; _objc_init åˆ°è¿™é‡Œï¼Œé€šè¿‡æºç ä¹ŸéªŒè¯äº† ä¸Šè¿°å †æ ˆçš„æµç¨‹ã€‚\nå¯åŠ¨å®Œæ•´æµç¨‹ ç®€åŒ–æµç¨‹å›¾ è¯¦ç»†æµç¨‹å›¾ å®é™…åº”ç”¨ mainä¹‹å‰ - è°ƒè¯• \u0026amp; ç›‘æµ‹ 1. Xcodeæ‰“å°pre-mainçš„æ—¶é—´ï¼šå¼€å‘ç¯å¢ƒXcode DYLD_PRINT_STATICS = 1  dylid loading time:åŠ¨æ€åº“åŠ è½½æ—¶é—´ï¼Œè½½å…¥åŠ¨æ€åº“,å°½å¯èƒ½ä½¿ç”¨ç³»ç»Ÿåº“,è‡ªå®šä¹‰åº“ï¼Œæœ€å¥½ä¸è¦å¤§äº6ä¸ªï¼ˆappleæ¨èï¼‰ rebaseï¼ˆä¿®æ­£åç§»æŒ‡é’ˆ ASLR-ä¿®å¤å†…éƒ¨æŒ‡é’ˆï¼‰ / binding time ï¼ˆå¤–éƒ¨ç¬¦å·ç»‘å®šï¼‰:ï¼ˆfishhookï¼‰ Objc set up timeï¼Œ å‡å°‘OCç±»ï¼Œæœ‰ç»Ÿè®¡2ä¸‡ä¸ªocç±»å¢åŠ 800æ¯«ç§’ï¼Œswiftæ¯”OCçš„æ•ˆç‡æ›´é«˜ï¼Œåˆ é™¤å¼ƒç”¨çš„ç±»ï¼ˆæ‰¾å·¥å…·æ£€æµ‹ï¼‰ initializer time loadæ–¹æ³• æ‡’åŠ è½½ï¼Œå°½é‡æ”¾åœ¨initialize å»è°ƒç”¨ slowest initializer:æœ€æ…¢çš„å‡ ä¸ªåº“çš„æ—¶é—´ libsystem:  2. Instrument - SystemTrace / TimeProfiler ä¼šè®°å½•å¯åŠ¨çš„ä¸€äº›ä¿¡æ¯\n3. Xcodeé…ç½®LinkMapï¼Œæ‹¿åˆ°LinkMapæ–‡ä»¶ï¼Œåˆ†æ 4. å…¶ä»–ï¼ˆ1ï¼Œ2ä¸æ¨èï¼Œå¼€æ‹“æ€è·¯ï¼‰  å®šæ—¶æŠ“å–ä¸»çº¿ç¨‹ä¸Šçš„æ–¹æ³•è°ƒç”¨å †æ ˆï¼ˆbacktraceï¼‰ï¼Œè®¡ç®—ä¸€æ®µæ—¶é—´é‡Œå„ä¸ªæ–¹æ³•çš„è€—æ—¶ã€‚ hook objc_msgSend æ–¹æ³•è¿›è¡Œhookï¼ŒæŒæ¡æ‰€æœ‰æ–¹æ³•çš„æ‰§è¡Œè€—æ—¶ ï¼ˆlibffi, facebook fishhookï¼‰ åœ¨å¯åŠ¨çš„ç›¸å…³æ—¶æœºæ’å…¥è‡ªå®šä¹‰çš„åŠ¨æ€åº“ï¼Œé…åˆæŠ€æœ¯åŸ‹ç‚¹ Apple-Metricsï¼ˆå¯è‡ªå®šä¹‰ï¼‰ é…åˆåˆ†æçº¿ä¸Š  ","date":"2022-03-25T00:00:00Z","permalink":"https://wangmingyou.github.io/p/ios-app-launch/","title":"iOSåº”ç”¨ç¨‹åºåŠ è½½"},{"content":"objc æºç  objc818-canrun\nobjc838-canrun\n","date":"2022-02-18T00:00:00Z","permalink":"https://wangmingyou.github.io/p/open_source/","title":"æºç å­¦ä¹ "},{"content":"å…¥å£ objc_msgSend æå‡ºç–‘é—® æ–¹æ³• -\u0026gt; æ¶ˆæ¯ï¼Œ å¦‚ä½•å‘é€çš„ï¼Ÿ\nsel-imp æ–¹æ³•ç¼–è¯‘ä¸ºå‡½æ•°é»˜è®¤æœ‰ä¸¤ä¸ªå‚æ•° ï¼ˆid selfï¼Œ SEL _cmdï¼‰\nself: æ¶ˆæ¯æ¥å—è€…\n_cmd: æ–¹æ³•ç¼–å·ï¼Œ æ‰¾åˆ°å…·ä½“å‡½æ•°å®ç°\nç›®å½• ï¼ˆSELï¼‰ï¼Œé¡µç ï¼ˆIMPï¼š æŒ‡å‘å‡½æ•°å…·ä½“å®ç°çš„æŒ‡é’ˆï¼‰ï¼Œå…·ä½“å†…å®¹ï¼ˆå‡½æ•°å®ç° ï¼‰\nå¦‚ä½•ä»SEL æ‰¾åˆ° IMP\næ±‡ç¼–ï¼Œæ–­ç‚¹æŸ¥çœ‹ libobjcæºç åˆ†æ è¿›å…¥æ±‡ç¼–æŸ¥æ‰¾è¿‡ç¨‹ objc-msg-arm64 ENTRY _objc_msgSend\nCacheLookup  CacheLookup, æœ‰ç¼“å­˜åˆ—è¡¨   CacheHitï¼Œæ‰¾åˆ°è¿”å›  ç›´æ¥ä»å¯„å­˜å™¨è·å–\nCheckMissï¼Œæ²¡æ‰¾åˆ°  æ­£å¸¸å°±æ˜¯ç”¨Normalè¿›æ¥çš„ï¼Œæ‰€ä»¥èµ°__objc_msgSend_uncached\nc. add æ·»åŠ è¿›å»ï¼Œæ–¹ä¾¿ä¸‹æ¬¡æ“ä½œ\nMethodTableLookup æˆ‘ä»¬éƒ½çŸ¥é“OCçš„å¯¹è±¡æœ€ç»ˆæ±‡ç¼–æˆç»“æ„ä½“ï¼Œç»“æ„ä½“æ˜¯Classï¼Œä¹Ÿå°±æ˜¯objc_class\nç”±æ­¤å¯ä»¥çœ‹åˆ°åœ¨ç»“æ„ä½“é‡Œé¢æœ‰ï¼š æ–¹æ³•åˆ—è¡¨ï¼Œå±æ€§åˆ—è¡¨ï¼Œåè®®åˆ—è¡¨\nruntime æ˜¯ç”± C, C++, æ±‡ç¼–æ··åˆæä¾›è¿è¡Œæ—¶åŠŸèƒ½ï¼Œ æ‰€ä»¥æœç´¢åˆ é™¤ä¸€ä¸ª\u0026quot;_\u0026quot;, æœç´¢\u0026quot;_class_lookupMethodAndLoadCache3\u0026quot;\nè¿›å…¥C/C++å‡½æ•°æ–¹æ³• æŸ¥æ‰¾è¿‡ç¨‹ æ­¤æ—¶å·²ç»ç¦»å¼€æ±‡ç¼–è¿‡ç¨‹ï¼ˆå¿«é€Ÿï¼‰ï¼Œä»lookUpImpOrForwardå¼€å§‹è¿›å…¥æ…¢é€ŸæŸ¥æ‰¾è¿‡ç¨‹\nclsï¼š Class ç±»å¯¹è±¡\nclsç±»å¯¹è±¡\nå®ä¾‹å¯¹è±¡\nå…ƒç±»å¯¹è±¡\nç»§æ‰¿å…³ç³»å®ç° å®é™…åº”ç”¨  NSObject åˆ†ç±»æ·»åŠ æ–¹æ³•ï¼Œé˜²æ­¢å´©æºƒ ç½‘ç»œè·å–æ•°æ®ï¼Œå¯èƒ½int/stringï¼Œint.lengthï¼Œä¸çŸ¥é“æ–¹æ³•æ˜¯ä»€ä¹ˆï¼Œåº”è¯¥åŠ¨æ€æ·»åŠ  é‡åˆ°å´©æºƒï¼Œæç¤ºé€€å‡ºé¡µé¢ï¼Œä¸ŠæŠ¥crashï¼ŒåŠ¨æ€å¤„ç†  åŠ¨æ€æ–¹æ³•è§£æ TypeEcoding v@: id:self, cmd -\u0026gt; void\næ¶ˆæ¯è½¬å‘ aspectï¼Œæ¶ˆæ¯è½¬å‘çš„å…·ä½“åº”ç”¨\næºç è·‘åŠŸèƒ½   æ¶ˆæ¯å‘é€çš„æµç¨‹å›¾ æ€»ç»“  æ–¹æ³•çš„æœ¬è´¨æ˜¯å‘é€æ¶ˆæ¯ï¼Œå‘é€æ¶ˆæ¯çš„å‡ ä¸ªæµç¨‹    å¿«é€ŸæŸ¥æ‰¾ï¼ˆobjc_msgSendï¼‰~ cache_t ç¼“å­˜æ¶ˆæ¯ æ…¢é€ŸæŸ¥æ‰¾ï½ é€’å½’è‡ªå·±ï½œçˆ¶ç±»ï½ lookupImpOrForWard æŸ¥ä¸åˆ°æ¶ˆæ¯ï¼šåŠ¨æ€â½…æ³•è§£æ~ resolveInstanceMethod æ¶ˆæ¯å¿«é€Ÿè½¬å‘~ forwardingTargetForSelector æ¶ˆæ¯æ…¢é€Ÿè½¬å‘~ methodSignatureForSelector \u0026amp; forwardInvocation   sel æ˜¯æ–¹æ³•ç¼–å·ï¼Œåœ¨read_imagesæœŸé—´å°±ç¼–è¯‘è¿›å†…å­˜ impæ˜¯å‡½æ•°å®ç°çš„æŒ‡é’ˆï¼Œæ‰¾impå°±æ˜¯æ‰¾å‡½æ•°   sel å¯ä»¥ç†è§£ä¸ºä¹¦æœ¬çš„ç›®å½•æ ‡é¢˜ï¼Œimpå°±æ˜¯ä¹¦æœ¬çš„é¡µç ã€‚æŸ¥æ‰¾å…·ä½“çš„å‡½æ•°ï¼Œå°±æ˜¯çœ‹è¿™æœ¬ä¹¦é‡Œé¢å…·ä½“çš„å†…å®¹ï¼Œé€šè¿‡æƒ³çœ‹çš„æ ‡é¢˜æ‰¾åˆ°å¯¹åº”çš„é¡µéª‚æœ€åç¿»åˆ°å…·ä½“çš„å†…å®¹ï¼Œå³æ˜¯ sel - æŒ‡é’ˆ(imp) - å…·ä½“å®ç°\n ","date":"2020-01-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/objc_msgsend/","title":"æ¶ˆæ¯å‘é€æºç å­¦ä¹ "},{"content":"ç›´æ¥çœ‹ä¸€æ®µä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @interface Person : NSObject @end @implementation Person @end @interface Worker : Person @end @implementation Worker - (instancetype)init{ self = [super init]; if (self) { NSLog(@\u0026#34;ğŸ¦ï¸ [self class] %@\u0026#34;,NSStringFromClass([self class])); NSLog(@\u0026#34;ğŸ¦ï¸ [super class] %@\u0026#34;,NSStringFromClass([super class])); } return self; } @end @implementation TestSuperClass // åˆ†æ [self class] ä¸ [super class] çš„åŒºåˆ« - (void) test { Worker *worker = [[Worker alloc] init]; } @end   æ‰“å°ç»“æœï¼š 1 2  2022-04-09 19:08:09.612737+0800 Object-CDemo[68945:1164926] ğŸ¦ï¸ [self class] Worker 2022-04-09 19:08:09.612854+0800 Object-CDemo[68945:1164926] ğŸ¦ï¸ [super class] Worker    ç›¸ä¿¡ä¸€ä¸ªæ‰“å°å¤§å®¶éƒ½å¾ˆå¥½ç†è§£ï¼Œç¬¬äºŒä¸ªå°±ä¸å¥½ç†è§£äº†ï¼Œé‚£ä¹ˆç°åœ¨ä¸»è¦æ¥åˆ†æä¸‹ super class\n  åœ¨objc æºç ä¸­ æ‰¾åˆ°class çš„æºç å®ç°\n 1 2 3 4 5 6 7  - (Class)class { /* 1. æ‰€æœ‰çš„å‡½æ•°ï¼Œéƒ½æœ‰ä¸¤ä¸ªé»˜è®¤çš„éšè—å‚æ•°ï¼š(id self , sel _cmd), è¿™é‡Œçš„ç”¨çš„selfå°±æ˜¯ç¬¬ä¸€ä¸ªéšè—å‚æ•°ï¼Œå°±æ˜¯æ¶ˆæ¯çš„æ¥å—ä½“ 2. ç°åœ¨çš„å…³é”®é—®é¢˜æ˜¯ï¼Œéšè—å‚æ•°self åˆ°åº•æ˜¯è°ï¼Œä¹Ÿå°±æ˜¯æ¶ˆæ¯çš„æ¥å—è€…æ˜¯è° */ return object_getClass(self); }    è¿™é‡Œæ˜¾è€Œæ˜“è§ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ª[self class]çš„selfæ˜¯workerå°±æ˜¾è€Œæ˜“è§äº†ã€‚é‚£ä¹ˆç¬¬äºŒä¸ªä¸ºä»€ä¹ˆä¹Ÿæ˜¯workerå‘¢ï¼Ÿ\n åˆ†æçš„å¸¸è§æ€è·¯ æ–¹æ³•1: clang çœ‹åˆ°åº•åº•å±‚ç¼–è¯‘æˆä»€ä¹ˆæ ·çš„æºç  æ–¹æ³•2: objcæºç  runèµ·æ¥ï¼Œç›´æ¥æ–­ç‚¹åˆ†æåˆ†æ æ–¹æ³•3: æ–­ç‚¹æ±‡ç¼– + æºç é…åˆ åˆ†æ æ–¹æ³•4: NSObject MethodSwizzling class æ–¹æ³•  å‰ä¸¤ç§æ–¹æ³•ï¼Œæˆ‘è§‰å¾—éƒ½æœ‰ç‚¹éº»çƒ¦ï¼Œæ–¹æ³•4ï¼ŒMethodSwizzlingä¹Ÿåªæ˜¯éªŒè¯æ‰“å°ç»“æœï¼Œå¯¹æˆ‘ä»¬åˆ†ææœ¬è´¨ï¼Œå¸®åŠ©å¯èƒ½ä¸å¤§ï¼Œæ‰€ä»¥æˆ‘ç›´æ¥é€‰æ‹©æ–¹æ³•3ï¼Œå¿«æ·è¿˜å¯ä»¥åˆ†æåº•å±‚åŸå› ã€‚\n æ–­ç‚¹æ±‡ç¼–åˆ†æ é¦–å…ˆé€‰æ‹©æ–­ç‚¹çš„æ±‡ç¼–æ¨¡å¼      è¿™é‡Œæ˜¾è€Œæ˜“è§ [super class] æœ€ç»ˆèµ°çš„æ˜¯objc_msgSendSuper2æ¶ˆæ¯å‘é€ï¼Œå†ç»“åˆæºç ã€‚\n 1 2 3  objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...) #endif   // é€šè¿‡objcæºç é‡Œé¢ç®€åŒ– objc_super\n1 2 3 4 5  struct objc_super { __unsafe_unretained _Nonnull id receiver; //æ¶ˆæ¯æ¥æ”¶è€… __unsafe_unretained _Nonnull Class super_class; };    ä¹Ÿå°±æ˜¯NSLog(@\u0026quot;ğŸ¦ï¸ [super class] %@\u0026quot;,NSStringFromClass([super class])) ç­‰åŒäºä¸‹é¢çš„ä¸€æ®µä»£ç \n 1 2 3 4 5 6  // [super class] ç­‰åŒäºä¸‹é¢ä¸€æ®µä»£ç  struct objc_super test_super = { self, // ç ”ç©¶å¯¹è±¡æ˜¯åœ¨workeré‡Œé¢ class_getSuperclass([self class]), }; NSLog(@\u0026#34;%@\u0026#34;,NSStringFromClass(objc_msgSendSuper2(\u0026amp;test_super,@selector(class))));    è½¬åŒ–åå¾ˆå¥½ç†è§£äº†ï¼Œå…¶å®å°±æ˜¯ç»™selfï¼ˆworkerï¼‰å‘é€æ¶ˆæ¯ï¼Œè°ƒç”¨classæ–¹æ³•ã€‚è¿™æ ·å°±èƒ½ç†è§£æ‰“å°ç»“æœäº†ã€‚\n é‚£ä¹ˆ [super class] ä¸ [self class] æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢  è™½ç„¶ç°åœ¨ç†è§£äº†ä¸¤è€…ç»“æœä¸€æ ·ï¼Œé‚£ä¹ˆ[super class] æœ‰ä»€ä¹ˆç‰¹æ®Šçš„å‘¢ï¼Ÿä¹Ÿå°±æ˜¯objc_super é‡Œé¢çš„ class_getSuperclass([self class]), å­˜åœ¨çš„æ„ä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ å…¶å®æœ¬è´¨åŒºåˆ«å°±æ˜¯objc_msgSendSuper ä¸objc_msgSend æœ‰ä»€ä¹ˆåŒºåˆ«?\n objc_msgSend æµç¨‹ objc_msgSendå…·ä½“æµç¨‹ å¯ä»¥çœ‹åˆ°è¿™ä¸ªobjc_msgSendæ…¢é€Ÿæµç¨‹å›å»éå†çˆ¶ç±»ï¼Œæ¯”è¾ƒæ…¢ï¼Œobjc_msgSendSuperå°±å¯ä»¥è·³è¿‡å¾ˆå¤šéå†ï¼Œå˜å¾—æ›´å¿«äº†ã€‚\nç»“è®º  [self class] å°±æ˜¯å‘é€æ¶ˆæ¯objc_msgSendï¼Œæ¶ˆæ¯æ¥å—è€…æ˜¯ self â½…æ³•ç¼–å·ï¼šclass [super class] æœ¬è´¨å°±æ˜¯objc_msgSendSuper, æ¶ˆæ¯çš„æ¥å—è€…è¿˜æ˜¯ self â½…æ³•ç¼–å·ï¼šclass é€»è¾‘æ•™è‚² åªæ˜¯objc_msgSendSuper ä¼šæ›´å¿« ç›´æ¥è·³è¿‡ self çš„æŸ¥æ‰¾\n ","date":"2019-03-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/super-class-study/","title":"åˆ†æ åœ¨OCä¸­ [self class] ä¸ [super class] çš„åŒºåˆ«"}]