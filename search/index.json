[{"content":"objc 源码 objc818-canrun\nobjc838-canrun\n","date":"2022-02-18T00:00:00Z","permalink":"https://wangmingyou.github.io/p/open_source/","title":"源码学习"},{"content":"Mac切换Python版本 找到安装的mac路径  系统自带的：/System/Library/Frameworks/Python.framework 自己安装的python3: /usr/local/Cellar/python@3.9/3.9.6/Frameworks/Python.framework\n 修改配置文件   找到根目录下的***.zshrc*** 或者 .bash_profile   修改文件 将如下内容添加到文件中,根据需求设置默认python版本\n  1 2 3  # python 配置 alias python=\u0026#39;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7\u0026#39; # alias python=\u0026#39;/usr/local/Cellar/python@3.9/3.9.6/Frameworks/Python.framework/Versions/3.9/bin/python3.9\u0026#39;   保存文件，在命令行执行source ~/.zshrc 或者 source ~/.bash_profile，是修改的内容生效\n查看生效后的python版本 在命令行执行python --version，查看版本。\n","date":"2022-01-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/mac-change-pyhton/","title":"Mac切换Python版本"},{"content":"入口 objc_msgSend 提出疑问 方法 -\u0026gt; 消息， 如何发送的？\nsel-imp 方法编译为函数默认有两个参数 （id self， SEL _cmd）\nself: 消息接受者\n_cmd: 方法编号， 找到具体函数实现\n目录 （SEL），页码（IMP： 指向函数具体实现的指针），具体内容（函数实现 ）\n如何从SEL 找到 IMP\n汇编，断点查看 libobjc源码分析 进入汇编查找过程 objc-msg-arm64 ENTRY _objc_msgSend\nCacheLookup  CacheLookup, 有缓存列表   CacheHit，找到返回  直接从寄存器获取\nCheckMiss，没找到  正常就是用Normal进来的，所以走__objc_msgSend_uncached\nc. add 添加进去，方便下次操作\nMethodTableLookup 我们都知道OC的对象最终汇编成结构体，结构体是Class，也就是objc_class\n由此可以看到在结构体里面有： 方法列表，属性列表，协议列表\nruntime 是由 C, C++, 汇编混合提供运行时功能， 所以搜索删除一个\u0026quot;_\u0026quot;, 搜索\u0026quot;_class_lookupMethodAndLoadCache3\u0026quot;\n进入C/C++函数方法 查找过程 此时已经离开汇编过程（快速），从lookUpImpOrForward开始进入慢速查找过程\ncls： Class 类对象\ncls类对象\n实例对象\n元类对象\n继承关系实现 实际应用  NSObject 分类添加方法，防止崩溃 网络获取数据，可能int/string，int.length，不知道方法是什么，应该动态添加 遇到崩溃，提示退出页面，上报crash，动态处理  动态方法解析 TypeEcoding v@: id:self, cmd -\u0026gt; void\n消息转发 aspect，消息转发的具体应用\n源码跑功能   消息发送的流程图 总结  方法的本质是发送消息，发送消息的几个流程    快速查找（objc_msgSend）~ cache_t 缓存消息 慢速查找～ 递归自己｜父类～ lookupImpOrForWard 查不到消息：动态⽅法解析~ resolveInstanceMethod 消息快速转发~ forwardingTargetForSelector 消息慢速转发~ methodSignatureForSelector \u0026amp; forwardInvocation   sel 是方法编号，在read_images期间就编译进内存 imp是函数实现的指针，找imp就是找函数   sel 可以理解为书本的目录标题，imp就是书本的页码。查找具体的函数，就是看这本书里面具体的内容，通过想看的标题找到对应的页骂最后翻到具体的内容，即是 sel - 指针(imp) - 具体实现\n ","date":"2020-01-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/objc_msgsend/","title":"消息发送源码学习"},{"content":"直接看一段代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @interface Person : NSObject @end @implementation Person @end @interface Worker : Person @end @implementation Worker - (instancetype)init{ self = [super init]; if (self) { NSLog(@\u0026#34;🦁️ [self class] %@\u0026#34;,NSStringFromClass([self class])); NSLog(@\u0026#34;🦁️ [super class] %@\u0026#34;,NSStringFromClass([super class])); } return self; } @end @implementation TestSuperClass // 分析 [self class] 与 [super class] 的区别 - (void) test { Worker *worker = [[Worker alloc] init]; } @end   打印结果： 1 2  2022-04-09 19:08:09.612737+0800 Object-CDemo[68945:1164926] 🦁️ [self class] Worker 2022-04-09 19:08:09.612854+0800 Object-CDemo[68945:1164926] 🦁️ [super class] Worker    相信一个打印大家都很好理解，第二个就不好理解了，那么现在主要来分析下 super class\n  在objc 源码中 找到class 的源码实现\n 1 2 3 4 5 6 7  - (Class)class { /* 1. 所有的函数，都有两个默认的隐藏参数：(id self , sel _cmd), 这里的用的self就是第一个隐藏参数，就是消息的接受体 2. 现在的关键问题是，隐藏参数self 到底是谁，也就是消息的接受者是谁 */ return object_getClass(self); }    这里显而易见，所以第一个[self class]的self是worker就显而易见了。那么第二个为什么也是worker呢？\n 分析的常见思路 方法1: clang 看到底底层编译成什么样的源码 方法2: objc源码 run起来，直接断点分析分析 方法3: 断点汇编 + 源码配合 分析 方法4: NSObject MethodSwizzling class 方法  前两种方法，我觉得都有点麻烦，方法4，MethodSwizzling也只是验证打印结果，对我们分析本质，帮助可能不大，所以我直接选择方法3，快捷还可以分析底层原因。\n 断点汇编分析 首先选择断点的汇编模式      这里显而易见 [super class] 最终走的是objc_msgSendSuper2消息发送，再结合源码。\n 1 2 3  objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...) #endif   // 通过objc源码里面简化 objc_super\n1 2 3 4 5  struct objc_super { __unsafe_unretained _Nonnull id receiver; //消息接收者 __unsafe_unretained _Nonnull Class super_class; };    也就是NSLog(@\u0026quot;🦁️ [super class] %@\u0026quot;,NSStringFromClass([super class])) 等同于下面的一段代码\n 1 2 3 4 5 6  // [super class] 等同于下面一段代码 struct objc_super test_super = { self, // 研究对象是在worker里面 class_getSuperclass([self class]), }; NSLog(@\u0026#34;%@\u0026#34;,NSStringFromClass(objc_msgSendSuper2(\u0026amp;test_super,@selector(class))));    转化后很好理解了，其实就是给self（worker）发送消息，调用class方法。这样就能理解打印结果了。\n 那么 [super class] 与 [self class] 有什么区别呢  虽然现在理解了两者结果一样，那么[super class] 有什么特殊的呢？也就是objc_super 里面的 class_getSuperclass([self class]), 存在的意义是什么呢？ 其实本质区别就是objc_msgSendSuper 与objc_msgSend 有什么区别?\n objc_msgSend 流程 objc_msgSend具体流程 可以看到这个objc_msgSend慢速流程回去遍历父类，比较慢，objc_msgSendSuper就可以跳过很多遍历，变得更快了。\n结论  [self class] 就是发送消息objc_msgSend，消息接受者是 self ⽅法编号：class [super class] 本质就是objc_msgSendSuper, 消息的接受者还是 self ⽅法编号：class 逻辑教育 只是objc_msgSendSuper 会更快 直接跳过 self 的查找\n ","date":"2019-03-15T00:00:00Z","permalink":"https://wangmingyou.github.io/p/super-class-study/","title":"分析 在OC中 [self class] 与 [super class] 的区别"}]