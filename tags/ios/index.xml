<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iOS on YoyoWong</title>
    <link>https://wangmingyou.github.io/tags/ios/</link>
    <description>Recent content in iOS on YoyoWong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://wangmingyou.github.io/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>iOS应用程序加载</title>
      <link>https://wangmingyou.github.io/p/ios-app-launch/</link>
      <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wangmingyou.github.io/p/ios-app-launch/</guid>
      <description>iOS应用程序加载 前言 这篇文章的核心目的是跟着苹果源码，深度学习并理解iOS APP启动过程。
基础概念 冷启动  冷启动 
 注意：在日常开发或测试的时候为了，触发冷启动状态，会手动kill app，然后点击启动。这种情况下的冷启动可能会与上述冷启动过程的步骤稍微少些，可以配合Instrument调试验证（这个在文章结尾会做介绍）。因此通常如果要模拟更真实全面的冷启动，在kill app后，再打开/并稍微使用几个其他app。
 通常说的启动，也是指的冷启动；启动优化大部分也是做冷启动部分的性能优化 暂且可以把冷启动分为几个阶段：
 T1: main之前，加载App可执行文件到内存，然后执行一系列的加载&amp;amp;链接等工作，最后执行到main()函数 T2: main之后，didFinishLaunching之前，这部分开发是可以监听到的 T3: didFinishLaunching之后，启动页面出现之前，也是可以监听的  热启动  热启动  热启动的阶段和状态都是可监听的，不做过多介绍。
应用程序的状态 启动程序 willFinishLaunchingWithOptions didFinishLaunchingWithOptions applicationDidBecomeActive 按下home键 applicationWillResignActive applicationDidEnterBackground 双击home键，再打开程序 applicationWillEnterForeground applicationDidBecomeActive 简单理解编译过程 应用程序加载过程中会依赖很多底层库，这些底层库其实就是可执行的代码的二进制，被操作系统写入到内存。  编译过程 
静态库 比如： .a, .lib 在链接阶段，会将汇编生成的目标与引用的库一起链接打包到可执行文件中。  静态库 
动态库 比如： framework，.so, .dll，UIKIT.framework， libsystem， libdispatch，libobjc 动态库根据需要编译，动态加载，在运行时才被载入，节约资源，减小体积。  动态库 
快速定位核心源码入口   main函数，断点堆栈（Debug/Debug Workflow/Always Show Disassembly 开启汇编Debug）可以看到是最早是：dyld的start:  main断点</description>
    </item>
    
    <item>
      <title>源码学习</title>
      <link>https://wangmingyou.github.io/p/open_source/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wangmingyou.github.io/p/open_source/</guid>
      <description>objc 源码 objc818-canrun
objc838-canrun</description>
    </item>
    
    <item>
      <title>消息发送源码学习</title>
      <link>https://wangmingyou.github.io/p/objc_msgsend/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wangmingyou.github.io/p/objc_msgsend/</guid>
      <description>入口 objc_msgSend 提出疑问 方法 -&amp;gt; 消息， 如何发送的？
sel-imp 方法编译为函数默认有两个参数 （id self， SEL _cmd）
self: 消息接受者
_cmd: 方法编号， 找到具体函数实现
目录 （SEL），页码（IMP： 指向函数具体实现的指针），具体内容（函数实现 ）
如何从SEL 找到 IMP
汇编，断点查看  
libobjc源码分析 进入汇编查找过程 objc-msg-arm64 ENTRY _objc_msgSend
CacheLookup  CacheLookup, 有缓存列表   CacheHit，找到返回  直接从寄存器获取
CheckMiss，没找到  正常就是用Normal进来的，所以走__objc_msgSend_uncached
c. add 添加进去，方便下次操作
MethodTableLookup 我们都知道OC的对象最终汇编成结构体，结构体是Class，也就是objc_class
由此可以看到在结构体里面有： 方法列表，属性列表，协议列表
runtime 是由 C, C++, 汇编混合提供运行时功能， 所以搜索删除一个&amp;quot;_&amp;quot;, 搜索&amp;quot;_class_lookupMethodAndLoadCache3&amp;quot;
进入C/C++函数方法 查找过程 此时已经离开汇编过程（快速），从lookUpImpOrForward开始进入慢速查找过程
cls： Class 类对象
cls类对象
实例对象
元类对象
继承关系实现 实际应用  NSObject 分类添加方法，防止崩溃 网络获取数据，可能int/string，int.</description>
    </item>
    
    <item>
      <title>分析 在OC中 [self class] 与 [super class] 的区别</title>
      <link>https://wangmingyou.github.io/p/super-class-study/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://wangmingyou.github.io/p/super-class-study/</guid>
      <description>直接看一段代码 @interface Person : NSObject @end @implementation Person @end @interface Worker : Person @end @implementation Worker - (instancetype)init{ self = [super init]; if (self) { NSLog(@&amp;quot;🦁️ [self class] %@&amp;quot;,NSStringFromClass([self class])); NSLog(@&amp;quot;🦁️ [super class] %@&amp;quot;,NSStringFromClass([super class])); } return self; } @end @implementation TestSuperClass // 分析 [self class] 与 [super class] 的区别 - (void) test { Worker *worker = [[Worker alloc] init]; } @end 打印结果： 2022-04-09 19:08:09.612737+0800 Object-CDemo[68945:1164926] 🦁️ [self class] Worker 2022-04-09 19:08:09.</description>
    </item>
    
  </channel>
</rss>
